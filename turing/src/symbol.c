#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[1580];
} TLFTAB =
    { 27,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'y', 'm', 'b', 'o', 'l', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'y', 'm', 'b', 'o', 'l', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 'b', 'd', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'g', 'l', 'o', 'b', 'a', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'f', '2', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'm', 'e', 'm', 'o', 'r', 'y', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'p', 'r', 'e', 's', 'c', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'o', 'p', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'v', 'a', 'l', 'u', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 't', 'y', 'p', 'e', 's', '.', 's', 't', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x2464[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x2464	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x2465[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x2468[21];
typedef	TLstring	__x2472[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x2476[22];
typedef	Language___x2476	Language___x2475[255];
extern Language___x2475	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x2478 {
    TLint4	lower, range;
};
typedef	struct Language___x2478	Language___x2477[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x2477	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x2479[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x2479	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x2480[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x2480	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x2483[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();

extern TLaddressint malloc ();

extern TLaddressint realloc ();

extern void free ();
typedef	TLnat1	Language_Compile_Tok;
typedef	TLchar	Language_Compile___x2488[16];
struct	Language_Compile___x2487 {
    Language_Compile___x2488	Name;
    TLnat2	Precedence;
};
typedef	struct Language_Compile___x2487	Language_Compile___x2486[159];
extern Language_Compile___x2486	Language_Compile_TokData;
typedef	TLint1	Language_Compile_PPTok;
typedef	TLchar	Language_Compile___x2490[8];
typedef	Language_Compile___x2490	Language_Compile___x2489[16];
extern Language_Compile___x2489	Language_Compile_PPTokName;
typedef	TLint1	Language_Compile_TypeKind;
typedef	TLchar	Language_Compile___x2492[16];
typedef	Language_Compile___x2492	Language_Compile___x2491[33];
extern Language_Compile___x2491	Language_Compile_TypeKindName;
typedef	TLchar	Language_Compile___x2494[16];
typedef	Language_Compile___x2494	Language_Compile___x2493[33];
extern Language_Compile___x2493	Language_Compile_TypeKindKeyword;
typedef	TLint1	Language_Compile_TyModes;
typedef	TLchar	Language_Compile___x2496[12];
typedef	Language_Compile___x2496	Language_Compile___x2495[10];
extern Language_Compile___x2495	Language_Compile_TyModeName;
typedef	TLnat2	Language_Compile_TyModesSet;
typedef	TLint2	Language_Compile_PredType;
typedef	Language_Compile_TypeKind	Language_Compile___x2497[27];
extern Language_Compile___x2497	Language_Compile_PredTypeKind;
typedef	Language_Compile_TyModesSet	Language_Compile___x2498[27];
extern Language_Compile___x2498	Language_Compile_PredTypeMode;
typedef	TLint2	Language_Compile_FormalType;
typedef	TLint2	Language_Compile_Predef;
typedef	TLchar	Language_Compile___x2501[20];
struct	Language_Compile___x2500 {
    Language_Compile___x2501	Name;
    Language_Compile_FormalType	FormalList;
    Language_Compile_PredType	ResultType;
};
typedef	struct Language_Compile___x2500	Language_Compile___x2499[25];
extern Language_Compile___x2499	Language_Compile_PredefData;
typedef	TLchar	Language_Compile___x2502[256];
struct	Language_Compile_CharDef {
    TLint4	len;
    Language_Compile___x2502	val;
};
struct	Language_Compile_IdentDef {
    struct Language_Compile_IdentDef	*nextIdent;
    Language_Compile_Tok	tok;
    Language_Compile_PPTok	ppTok;
    Language_StringDef	str;
};
typedef	TLint1	Language_Compile_SymbolKind;
typedef	TLchar	Language_Compile___x2504[14];
typedef	Language_Compile___x2504	Language_Compile___x2503[10];
extern Language_Compile___x2503	Language_Compile_SymbolKindName;
typedef	TLint1	Language_Compile_Access;
typedef	TLchar	Language_Compile___x2506[6];
typedef	Language_Compile___x2506	Language_Compile___x2505[3];
extern Language_Compile___x2505	Language_Compile_AccessName;
typedef	TLint1	Language_Compile_SyAttributes;
typedef	TLchar	Language_Compile___x2508[16];
typedef	Language_Compile___x2508	Language_Compile___x2507[20];
extern Language_Compile___x2507	Language_Compile_SyAttribName;
typedef	TLnat4	Language_Compile_SyAttributeSet;
typedef	TLnat1	Language_Compile_ImportDepthType;
struct	Language_Compile_IndexDef {
    struct Language_Compile_IndexDef	*next;
    struct Language_Compile_TypeDef	*ty;
};
typedef	TLint1	Language_Compile_ExportKind;
typedef	TLchar	Language_Compile___x2510[16];
typedef	Language_Compile___x2510	Language_Compile___x2509[4];
extern Language_Compile___x2509	Language_Compile_ExportKindName;
typedef	TLnat1	Language_Compile_ExportKindSet;
struct	Language_Compile_ExportDef {
    struct Language_Compile_ExportDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_SymbolDef	*symbolPtr;
    struct Language_Compile_TypeDef	*opaqueTypePtr;
    Language_Compile_ExportKindSet	kind;
};
struct	Language_Compile_ImportDef {
    struct Language_Compile_ImportDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    Language_Compile_Access	newAccess;
    Language_Compile_Access	oldAccess;
    Language_Compile_ImportDepthType	oldImportDepth;
    TLboolean	overridesExpand;
};
struct	Language_Compile_DynamicDef {
    struct Language_Compile_DynamicDef	*next;
    struct Language_Compile_SymbolDef	*sy;
};
typedef	TLint1	Language_Compile_BlockKind;
typedef	TLchar	Language_Compile___x2512[10];
typedef	Language_Compile___x2512	Language_Compile___x2511[16];
extern Language_Compile___x2511	Language_Compile_BlockKindName;
struct	Language_Compile_BlockDef {
    struct Language_Compile_BlockDef	*parentBlock;
    struct Language_Compile_BlockDef	*siblingBlock;
    struct Language_Compile_BlockDef	*childBlock;
    struct Language_Compile_BlockDef	*expandBlock;
    struct Language_Compile_SymbolDef	*internalSymbols;
    struct Language_Compile_SymbolDef	*parentSymbols;
    struct Language_Compile_SymbolDef	*definingSymbol;
    Language_Offset	codeStartOffset;
    Language_Offset	codeEndOffset;
    struct Language_Compile_DynamicDef	*dynamics;
    Language_Compile_BlockKind	kind;
    TLboolean	reachable;
    TLboolean	resolvingNeeded;
};
typedef	TLint1	Language_Compile_Base;
typedef	TLchar	Language_Compile___x2514[12];
typedef	Language_Compile___x2514	Language_Compile___x2513[10];
extern Language_Compile___x2513	Language_Compile_BaseName;
typedef	TLint1	Language_Compile_Indirection;
typedef	TLchar	Language_Compile___x2516[10];
typedef	Language_Compile___x2516	Language_Compile___x2515[3];
extern Language_Compile___x2515	Language_Compile_IndirName;
struct	Language_Compile_Location {
    void	*unitPtr;
    Language_Compile_Base	base;
    Language_Compile_Indirection	indir;
    Language_Offset	offset;
};
extern struct Language_Compile_Location	Language_Compile_nullLocation;
struct	Language_Compile_DeferredLocDef {
    struct Language_Compile_DeferredLocDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    struct Language_Compile_Location	loc;
};
struct	Language_Compile___x2517 {
    Language_Compile_SymbolKind	syTag;
    union {
	struct {
	    struct Language_Compile_SymbolDef	*mExpandSy;
	    struct Language_Compile_ImportDef	*mImportsOf;
	    struct Language_Compile_ExportDef	*mExportsOf;
	    Language_Compile_ExportKindSet	mExportAllKind;
	    struct Language_Compile_SymbolDef	*mMonitorVar;
	    struct Language_Compile_SymbolDef	*mClassTagSy;
	    TLint4	mDeferredNum;
	    struct Language_Compile_DeferredLocDef	*mDeferredLocs;
	} __u2;
	struct {
	    struct Language_Compile_ValueDef	*cValue;
	} __u3;
	struct {
	    struct Language_Compile_SymbolDef	*fFormalsOf;
	    struct Language_Compile_ImportDef	*fImportsOf;
	    struct Language_Compile_SymbolDef	*ResultsId;
	    struct Language_Compile_TypeDef	*ResultType;
	} __u4;
	struct {
	    struct Language_Compile_SymbolDef	*pFormalsOf;
	    struct Language_Compile_ImportDef	*pImportsOf;
	    struct Language_Compile_ValueDef	*pValue;
	} __u5;
	struct {
	    TLint4	unionNumber;
	} __u6;
    } __u1;
} ;
struct	Language_Compile_SymbolDef {
    struct Language_Compile_SymbolDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_TypeDef	*tyPtr;
    Language_Compile_Access	access;
    Language_Compile_ImportDepthType	importDepth;
    Language_Compile_Predef	predefined;
    Language_Compile_SyAttributeSet	attributes;
    struct Language_Compile_SymbolDef	*definingSy;
    struct Language_Compile_BlockDef	*blockScope;
    struct Language_Compile_Location	loc;
    struct SrcPosition	srcPos;
    Language_Offset	definingOffset;
    struct Language_Compile___x2517	u;
};
struct	Language_Compile_IntListDef {
    struct Language_Compile_IntListDef	*next;
    TLint4	value;
};
struct	Language_Compile_UnionDef {
    struct Language_Compile_UnionDef	*next;
    struct Language_Compile_SymbolDef	*firstSym;
    TLint4	numSyms;
    struct Language_Compile_IntListDef	*values;
    TLint4	uloc;
};
struct	Language_Compile___x2518 {
    Language_Compile_TypeKind	tyTag;
    union {
	struct {
	    struct Language_Compile_IndexDef	*IndexOf;
	    struct Language_Compile_TypeDef	*aElementOf;
	    struct Language_Compile_Location	aDescriptor;
	} __u8;
	struct {
	    struct Language_Compile_SymbolDef	*cNameOf;
	    struct Language_Compile_TypeDef	*cPointerTy;
	    struct Language_Compile_TypeDef	*cUPointerTy;
	} __u9;
	struct {
	    struct Language_Compile_SymbolDef	*EnumIds;
	    struct Language_Compile_Location	eDescriptor;
	} __u10;
	struct {
	    struct Language_Compile_BlockDef	*blockLevel;
	} __u11;
	struct {
	    struct Language_Compile_SymbolDef	*sNameOf;
	} __u12;
	struct {
	    struct Language_Compile_SymbolDef	*oNameOf;
	    struct Language_Compile_TypeDef	*tyOf;
	} __u13;
	struct {
	    struct Language_Compile_SymbolDef	*pNameOf;
	    struct Language_Compile_TypeDef	*pElementOf;
	} __u14;
	struct {
	    struct Language_Compile_SymbolDef	*rFieldsOf;
	} __u15;
	struct {
	    struct Language_Compile_TypeDef	*BaseOf;
	    TLboolean	sIsScalar;
	} __u16;
	struct {
	    TLint4	stringSize;
	} __u17;
	struct {
	    struct Language_Compile_Location	sDescriptor;
	} __u18;
	struct {
	    TLint4	low;
	    TLint4	high;
	    struct Language_Compile_TypeDef	*Root;
	} __u19;
	struct {
	    struct Language_Compile_SymbolDef	*TagOf;
	    struct Language_Compile_SymbolDef	*uFieldsOf;
	    struct Language_Compile_UnionDef	*map;
	    struct Language_Compile_Location	mapLocation;
	    struct Language_Compile_Location	uninitMap;
	} __u20;
	struct {
	    struct Language_Compile_TypeDef	*tyPtr;
	} __u21;
    } __u7;
} ;
struct	Language_Compile_TypeDef {
    struct Language_Compile_SymbolDef	*typeName;
    Language_Compile_TyModesSet	mode;
    TLint1	alignment;
    struct Language_Compile_Location	uninitTableLoc;
    TLint4	tSize;
    struct Language_Compile___x2518	u;
};
typedef	TLint1	Language_Compile_ValueKind;
typedef	TLchar	Language_Compile___x2520[16];
typedef	Language_Compile___x2520	Language_Compile___x2519[9];
extern Language_Compile___x2519	Language_Compile_ValueKindName;
typedef	TLnat4	Language_Compile_ValueSetType;
struct	Language_Compile___x2521 {
    Language_Compile_ValueKind	valTag;
    union {
	struct {
	    struct Language_Compile_ValueDef	*next;
	} __u23;
	struct {
	    TLboolean	boolVal;
	} __u24;
	struct {
	    TLchar	charVal;
	} __u25;
	struct {
	    struct Language_Compile_CharDef	*cstrVal;
	} __u26;
	struct {
	    TLboolean	negative;
	    TLnat4	natVal;
	} __u27;
	struct {
	    TLreal8	realVal;
	} __u28;
	struct {
	    Language_Compile_ValueSetType	setVal;
	} __u29;
	struct {
	    Language_StringDef	*stringVal;
	} __u30;
    } __u22;
} ;
struct	Language_Compile_ValueDef {
    TLboolean	saved;
    struct Language_Compile___x2521	u;
};
struct	Language_Compile___x2522 {
    Language_Compile_Tok	tok;
    union {
	struct {
	    struct Language_Compile_CharDef	*cstrPtr;
	} __u32;
	struct {
	    TLnat4	natVal;
	} __u33;
	struct {
	    TLreal8	realVal;
	} __u34;
	struct {
	    Language_StringDef	*strPtr;
	} __u35;
    } __u31;
} ;
struct	Language_Compile_TokRecord {
    struct SrcPosition	srcPos;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile___x2522	u;
};
extern struct Language_Compile_TokRecord	Language_Compile_newTok;
extern struct Language_Compile_TokRecord	Language_Compile_oldTok;

extern char *strcpy ();

void Language_Compile_CleanChar ();

void Language_Compile_CleanCString ();

void Language_Compile_IdentToName ();

void Language_Compile_TokenToName ();

void Language_Compile_SymbolToName ();
extern void	*Language_Compile_compilingUnit;
extern void	*Language_Compile_predefUnit;

extern void Language_Compile_CompileError_Add ();

extern void Language_Compile_CompileError_Initialize ();

extern TLnat4 Language_Compile_CompileError_Count ();

extern void Language_Compile_Memory_Initialize ();

extern void Language_Compile_Memory_Allocate ();

extern void Language_Compile_Memory_Trim ();
typedef	struct Language_Compile_IdentDef	*Language_Compile___x2543[118];
extern Language_Compile___x2543	Language_Compile_keywordIdent;
struct	Language_Compile___x2544 {
    struct Language_Compile_IdentDef	*anyclass;
    struct Language_Compile_IdentDef	*main;
    struct Language_Compile_IdentDef	*unit;
};
extern struct Language_Compile___x2544	Language_Compile_specialIdent;

extern void Language_Compile_Scanner_Reset ();

extern void Language_Compile_Scanner_EnterTok ();

extern void Language_Compile_Scanner_Initialize ();

extern void Language_Compile_Scanner_Scan ();

extern void Language_Compile_Scanner_GetFileUnit ();
typedef	TLstring	__x2545[20];

extern void Language_Compile_Scanner_EnterPreprocSymbols ();

void Language_Compile_DemandToken ();

void Language_Compile_ExpectToken ();

void Language_Compile_ExpectEnd ();

void Language_Compile_EqWantColonEq ();

void Language_Compile_GetUnitFile ();

void Language_Compile_InitializeScan ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_PreScan_VerifyConfiguration ();

extern void Language_Compile_PreScan_VerifyPredefList ();
extern struct Language_Compile_BlockDef	*Language_Compile_rootBlock;
extern struct Language_Compile_BlockDef	*Language_Compile_blockStack;
extern struct Language_Compile_SymbolDef	*Language_Compile_compilingSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_monitorSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_classSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_subprogramSymbol;
extern Language_Compile_ImportDepthType	Language_Compile_currentImportDepth;
extern struct Language_Compile_ValueDef	*Language_Compile_nonCompileTimeValue;
extern struct Language_Compile_ValueDef	*Language_Compile_intValueOne;
typedef	struct Language_Compile_TypeDef	*Language_Compile___x2554[27];
extern Language_Compile___x2554	Language_Compile_predType;
extern TLint4	Language_Compile_debugFile;
extern void 	(*Language_Compile_DumpAll)();
extern void 	(*Language_Compile_procDumpSym)();
extern void 	(*Language_Compile_procDumpSymList)();
extern void 	(*Language_Compile_procTargetType)();

void Language_Compile_OutputIndent ();

extern TLboolean Language_Compile_Scope_AncestorOf ();

extern TLboolean Language_Compile_Scope_AtTopLevel ();

extern TLboolean Language_Compile_Scope_ExpandScopeOk ();

extern struct Language_Compile_ExportDef * Language_Compile_Scope_IdentInExportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImmediateScope ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInScope ();

extern TLboolean Language_Compile_Scope_InBlock ();

extern void Language_Compile_Scope_DumpBlocks ();

extern struct Language_Compile_CharDef * Language_Compile_Value_CharValue ();

extern void Language_Compile_Value_Chr ();

extern void Language_Compile_Value_ConvertToChar ();

extern void Language_Compile_Value_ConvertToCharString ();

extern void Language_Compile_Value_ConvertToReal ();

extern void Language_Compile_Value_ConvertToString ();

extern void Language_Compile_Value_EnterSetValue ();

extern void Language_Compile_Value_Initialize ();

extern TLint4 Language_Compile_Value_IntValue ();

extern Language_Compile_ValueKind Language_Compile_Value_Kind ();

extern void Language_Compile_Value_NonCompileTimeOperation ();

extern void Language_Compile_Value_Ord ();

extern void Language_Compile_Value_PerformOperation ();

extern void Language_Compile_Value_PerformUnaryOperation ();

extern void Language_Compile_Value_Pop ();

extern void Language_Compile_Value_Push ();

extern void Language_Compile_Value_PushCopy ();

extern void Language_Compile_Value_PushInt ();

extern void Language_Compile_Value_PushSet ();

extern void Language_Compile_Value_PushToken ();

extern TLreal8 Language_Compile_Value_RealValue ();

extern void Language_Compile_Value_ReplaceLowHighWithEmptySet ();

extern void Language_Compile_Value_ReplaceLowHighWithSetAll ();

extern void Language_Compile_Value_ReplaceNonCompileTime ();

extern void Language_Compile_Value_Save ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Second ();

extern Language_StringDef * Language_Compile_Value_StringValue ();

extern void Language_Compile_Value_Swap ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Top ();

extern Language_Compile_ValueKind Language_Compile_Value_ValKind ();

extern struct Language_Compile_TypeDef * Language_Compile_Value_ValueType ();

extern void Language_Compile_Value_AssertStackEmpty ();

extern void Language_Compile_Value_DumpValue ();

extern void Language_Compile_Value_DumpValueStack ();

extern TLint4 Language_Compile_Types_Alignment ();

extern TLboolean Language_Compile_Types_Assignable ();

extern void Language_Compile_Types_ClearMode ();

extern void Language_Compile_Types_EnterAlignment ();

extern void Language_Compile_Types_EnterDescriptorLocation ();

extern void Language_Compile_Types_EnterElementType ();

extern void Language_Compile_Types_EnterIndices ();

extern void Language_Compile_Types_EnterMode ();

extern void Language_Compile_Types_EnterPointerType ();

extern void Language_Compile_Types_EnterPointerUncheckedType ();

extern void Language_Compile_Types_EnterSetBase ();

extern void Language_Compile_Types_EnterSize ();

extern void Language_Compile_Types_EnterStorageSize ();

extern void Language_Compile_Types_EnterTypeName ();

extern void Language_Compile_Types_EnterUnionInfo ();

extern void Language_Compile_Types_EnterUnionTag ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_EnumIds ();

extern TLboolean Language_Compile_Types_EquivVarType ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_FieldsOf ();

extern TLboolean Language_Compile_Types_HasMode ();

extern TLint4 Language_Compile_Types_High ();

extern struct Language_Compile_IndexDef * Language_Compile_Types_IndexOf ();

extern void Language_Compile_Types_Initialize ();

extern TLboolean Language_Compile_Types_IsCondition ();

extern TLboolean Language_Compile_Types_IsDynamicType ();

extern TLboolean Language_Compile_Types_IsIntType ();

extern TLboolean Language_Compile_Types_IsNumeric ();

extern TLboolean Language_Compile_Types_IsScalar ();

extern Language_Compile_TypeKind Language_Compile_Types_Kind ();

extern void Language_Compile_Types_LinkIdentListToType ();

extern TLint4 Language_Compile_Types_Low ();

extern void Language_Compile_Types_MakeTypeOpaque ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_NameOf ();

extern Language_Compile_TypeKind Language_Compile_Types_NumericKind ();

extern void Language_Compile_Types_NumericType ();

extern void Language_Compile_Types_Pack ();

extern void Language_Compile_Types_Pop ();

extern void Language_Compile_Types_PushBaseOf ();

extern void Language_Compile_Types_PushElementType ();

extern void Language_Compile_Types_PushNew ();

extern void Language_Compile_Types_PushTagType ();

extern void Language_Compile_Types_PushType ();

extern void Language_Compile_Types_ReplaceCopy ();

extern void Language_Compile_Types_ReplaceElementType ();

extern void Language_Compile_Types_ReplacePointerType ();

extern void Language_Compile_Types_ReplaceRootType ();

extern void Language_Compile_Types_ReplaceSecondRootType ();

extern void Language_Compile_Types_ReplaceType ();

extern void Language_Compile_Types_ResetPredefines ();

extern void Language_Compile_Types_ResolveForward ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_RootType ();

extern Language_Compile_TypeKind Language_Compile_Types_RootTypeKind ();

extern TLboolean Language_Compile_Types_Same ();

extern TLboolean Language_Compile_Types_SameType ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Second ();

extern Language_Compile_TypeKind Language_Compile_Types_SecondKind ();

extern TLint4 Language_Compile_Types_StrSize ();

extern TLboolean Language_Compile_Types_StringComparisonTypes ();

extern TLboolean Language_Compile_Types_StringTypes ();

extern void Language_Compile_Types_Swap ();

extern struct Language_Compile_SymbolDef * Language_Compile_Types_Tag ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Third ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_Top ();

extern TLint4 Language_Compile_Types_TypeSize ();

extern struct Language_Compile_UnionDef * Language_Compile_Types_UnionMap ();

extern void Language_Compile_Types_UnmakeTypeOpaque ();

extern struct Language_Compile_TypeDef * Language_Compile_Types_UnOpaqueType ();

extern TLboolean Language_Compile_Types_UnresolvedCollection ();

extern void Language_Compile_Types_AssertStackEmpty ();

extern void Language_Compile_Types_DumpType ();

extern void Language_Compile_Types_DumpTypeStack ();
typedef	TLint2	Language_Compile_Symbol_NewSymKinds;

void Language_Compile_Symbol_AddDeferredLocation ();

void Language_Compile_Symbol_AddExport ();

void Language_Compile_Symbol_AddImport ();

struct Language_Compile_BlockDef * Language_Compile_Symbol_BlockScope ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ClassTagSy ();

void Language_Compile_Symbol_ClearAttribute ();

void Language_Compile_Symbol_ClearSubprogramImports ();

void Language_Compile_Symbol_EnterAttribute ();

void Language_Compile_Symbol_EnterBlockScope ();

void Language_Compile_Symbol_EnterClassTag ();

void Language_Compile_Symbol_EnterExpand ();

void Language_Compile_Symbol_EnterFormals ();

void Language_Compile_Symbol_EnterInterruptProcedureValue ();

void Language_Compile_Symbol_EnterKind ();

void Language_Compile_Symbol_EnterLocation ();

void Language_Compile_Symbol_EnterMonitorVar ();

void Language_Compile_Symbol_EnterResultType ();

void Language_Compile_Symbol_EnterResultsId ();

void Language_Compile_Symbol_EnterType ();

void Language_Compile_Symbol_EnterValue ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ExpandSy ();

struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportedIdent ();

struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportsOf ();

void Language_Compile_Symbol_FixImportedSymbols ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_FormalsOf ();

TLboolean Language_Compile_Symbol_HasAttribute ();

struct Language_Compile_ImportDef * Language_Compile_Symbol_ImportsOf ();

void Language_Compile_Symbol_Initialize ();

TLboolean Language_Compile_Symbol_IsDoubleIndirect ();

Language_Compile_SymbolKind Language_Compile_Symbol_Kind ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_MonitorVar ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Nth ();

Language_Compile_Predef Language_Compile_Symbol_Predefined ();

void Language_Compile_Symbol_Pop ();

void Language_Compile_Symbol_PushDummy ();

void Language_Compile_Symbol_PushIdent ();

void Language_Compile_Symbol_PushLimitedNew ();

void Language_Compile_Symbol_PushNamedNew ();

void Language_Compile_Symbol_PushNew ();

void Language_Compile_Symbol_PushPointerTarget ();

void Language_Compile_Symbol_PushSymbol ();

void Language_Compile_Symbol_ReplaceDummy ();

void Language_Compile_Symbol_ResetSymbolList ();

void Language_Compile_Symbol_ResolveExport ();

struct Language_Compile_TypeDef * Language_Compile_Symbol_ResultType ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ResultsId ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Second ();

Language_Compile_SymbolKind Language_Compile_Symbol_SecondKind ();

struct Language_Compile_TypeDef * Language_Compile_Symbol_SecondType ();

void Language_Compile_Symbol_SetExportAll ();

void Language_Compile_Symbol_SetPervasive ();

TLboolean Language_Compile_Symbol_SubprogramVariable ();

Language_Compile_Access Language_Compile_Symbol_SyAccess ();

struct Language_Compile_ValueDef * Language_Compile_Symbol_SyValue ();

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Top ();

struct Language_Compile_TypeDef * Language_Compile_Symbol_Type ();

void Language_Compile_Symbol_AssertStackEmpty ();

void Language_Compile_Symbol_DumpSymbol ();

void Language_Compile_Symbol_DumpSymbolList ();

void Language_Compile_Symbol_DumpSymbolStack ();
static TLint2	Language_Compile_Symbol_symbolTop;
typedef	struct Language_Compile_SymbolDef	*Language_Compile_Symbol___x2557[30];
static Language_Compile_Symbol___x2557	Language_Compile_Symbol_symbolStack;

void Language_Compile_Symbol_PushSymbol (sy)
struct Language_Compile_SymbolDef	*sy;
{
    TLSTKCHKSLF(100028);
    TLSETF();
    TLSETL(100028);
    TLPRE (sy != ((struct Language_Compile_SymbolDef *) 0));
    TLINCL();
    if (Language_Compile_Symbol_symbolTop == 30) {
	TLSETL(100032);
	Language_Compile_CompileError_Add((TLint2) 10278, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 3);
    };
    TLSETL(100033);
    Language_Compile_Symbol_symbolTop += 1;
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)] = sy;
    TLRESTORELF();
}
static struct Language_Compile_SymbolDef	*Language_Compile_Symbol_freeSymbolChain;

void Language_Compile_Symbol_PushNamedNew (identPtr)
struct Language_Compile_IdentDef	*identPtr;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100045);
    TLSETF();
    TLSETL(100045);
    sy = Language_Compile_Symbol_freeSymbolChain;
    TLINCL();
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	struct Language_Compile_SymbolDef	*ns;
	TLSETL(100049);
	Language_Compile_Memory_Allocate(&(ns), (TLint2) sizeof(struct Language_Compile_SymbolDef));
	sy = ns;
    } else {
	TLSETL(100051);
	Language_Compile_Symbol_freeSymbolChain = sy->next;
    };
    TLSETL(100054);
    sy->next = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    sy->identPtr = identPtr;
    TLINCL();
    sy->tyPtr = Language_Compile_predType[26];
    TLINCL();
    sy->access = 0;
    TLINCL();
    if (Language_Compile_Symbol_symbolTop == 0) {
	TLSETL(100059);
	sy->importDepth = Language_Compile_currentImportDepth + 1;
    } else {
	TLSETL(100061);
	sy->importDepth = Language_Compile_currentImportDepth;
    };
    TLSETL(100063);
    sy->predefined = 0;
    TLINCL();
    sy->attributes = 0x0;
    TLINCL();
    sy->definingSy = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    sy->blockScope = (struct Language_Compile_BlockDef *) 0;
    TLINCL();
    TLSTRCTASS(sy->loc, Language_Compile_nullLocation, struct Language_Compile_Location);
    TLINCL();
    sy->loc.unitPtr = Language_Compile_compilingUnit;
    TLSETL(100070);
    TLSTRCTASS(sy->srcPos, Language_Compile_oldTok.srcPos, struct SrcPosition);
    TLINCL();
    sy->definingOffset = 0;
    TLSETL(100073);
    sy->u.syTag = 0;
    TLSETL(100076);
    Language_Compile_Symbol_PushSymbol(sy);
    TLRESTORELF();
}

void Language_Compile_Symbol_PushNew (symType)
Language_Compile_Symbol_NewSymKinds	symType;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100080);
    TLSETF();
    TLSETL(100080);
    sy = Language_Compile_Scope_IdentInScope(Language_Compile_oldTok.identPtr);
    TLSETL(100082);
    if ((sy != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->importDepth) >= Language_Compile_currentImportDepth)) {
	TLSETL(100084);
	switch (symType) {
	    case 0:
		break;
	    case 1:
		{
		    TLSETL(100088);
		    if ((((sy->u.syTag) == 6) && ((TLSMLSETCONST(8) & (sy->attributes)) != 0)) && ((sy->access) == 0)) {
			TLSETL(100091);
			if ((sy->blockScope) == Language_Compile_blockStack) {
			    TLSETL(100094);
			    Language_Compile_Symbol_PushSymbol(sy);
			    TLINCL();
			    TLRESTORELF();
			    return;
			};
			TLSETL(100099);
			{
			    TLstring	__x2558;
			    Language_Compile_SymbolToName(sy, __x2558);
			    Language_Compile_CompileError_Add((TLint2) 10085, &(Language_Compile_oldTok.srcPos), __x2558, "", (Language_ErrorSeverity) 2);
			};
		    };
		}
		break;
	    case 2:
		{
		    TLSETL(100102);
		    if (((sy->u.syTag) == 8) && ((TLSMLSETCONST(8) & (sy->attributes)) != 0)) {
			TLSETL(100104);
			if ((sy->blockScope) == Language_Compile_blockStack) {
			    TLSETL(100107);
			    Language_Compile_Symbol_PushSymbol(sy);
			    TLINCL();
			    TLRESTORELF();
			    return;
			};
			TLSETL(100112);
			{
			    TLstring	__x2559;
			    Language_Compile_SymbolToName(sy, __x2559);
			    Language_Compile_CompileError_Add((TLint2) 10086, &(Language_Compile_oldTok.srcPos), __x2559, "", (Language_ErrorSeverity) 2);
			};
		    };
		}
		break;
	    default:
		TLCASEABORT;
	};
	TLSETL(100114);
	if (((sy->predefined) != 0) || Language_UnitManager_IsPredef(sy->loc.unitPtr)) {
	    TLSETL(100119);
	    {
		TLstring	__x2560;
		Language_Compile_SymbolToName(sy, __x2560);
		Language_Compile_CompileError_Add((TLint2) 10222, &(Language_Compile_oldTok.srcPos), __x2560, "", (Language_ErrorSeverity) 2);
	    };
	} else {
	    TLSETL(100122);
	    {
		TLstring	__x2561;
		Language_Compile_SymbolToName(sy, __x2561);
		Language_Compile_CompileError_Add((TLint2) 10261, &(Language_Compile_oldTok.srcPos), __x2561, "", (Language_ErrorSeverity) 2);
	    };
	};
    };
    TLSETL(100126);
    Language_Compile_Symbol_PushNamedNew(Language_Compile_oldTok.identPtr);
    TLRESTORELF();
}

void Language_Compile_Symbol_PushLimitedNew (sList)
struct Language_Compile_SymbolDef	*sList;
{
    struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100134);
    TLSETF();
    TLSETL(100134);
    sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    if ((sy->identPtr) == (Language_Compile_oldTok.identPtr)) {
	TLSETL(100138);
	{
	    TLstring	__x2562;
	    Language_Compile_SymbolToName(sy, __x2562);
	    Language_Compile_CompileError_Add((TLint2) 10261, &(Language_Compile_oldTok.srcPos), __x2562, "", (Language_ErrorSeverity) 2);
	};
    } else {
	TLSETL(100139);
	sy = Language_Compile_Scope_IdentInList(sList);
	TLINCL();
	if (sy != ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100143);
	    {
		TLstring	__x2563;
		Language_Compile_SymbolToName(sy, __x2563);
		Language_Compile_CompileError_Add((TLint2) 10261, &(Language_Compile_oldTok.srcPos), __x2563, "", (Language_ErrorSeverity) 2);
	    };
	};
    };
    TLSETL(100146);
    Language_Compile_Symbol_PushNamedNew(Language_Compile_oldTok.identPtr);
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterKind (kind, access)
Language_Compile_SymbolKind	kind;
Language_Compile_Access	access;
{
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100150);
    TLSETF();
    TLSETL(100150);
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    (*sy).access = access;
    TLINCL();
    if ((Language_Compile_Symbol_symbolTop > 1) && (((*sy).definingSy) == ((struct Language_Compile_SymbolDef *) 0))) {
	TLSETL(100153);
	(*sy).definingSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)];
    };
    TLSETL(100156);
    (*sy).u.syTag = kind;
    TLSETL(100159);
    switch (kind) {
	case 1:
	case 5:
	    {
		TLSETL(100161);
		(*sy).u.__u1.__u2.mExpandSy = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u2.mImportsOf = (struct Language_Compile_ImportDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u2.mExportsOf = (struct Language_Compile_ExportDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u2.mExportAllKind = 0x0;
		TLINCL();
		(*sy).u.__u1.__u2.mMonitorVar = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u2.mClassTagSy = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u2.mDeferredNum = 0;
		TLINCL();
		(*sy).u.__u1.__u2.mDeferredLocs = (struct Language_Compile_DeferredLocDef *) 0;
	    }
	    break;
	case 3:
	    {
		TLSETL(100171);
		(*sy).attributes |= 0x1000;
		TLINCL();
		(*sy).u.__u1.__u3.cValue = Language_Compile_nonCompileTimeValue;
	    }
	    break;
	case 4:
	    {
		TLSETL(100175);
		(*sy).loc.unitPtr = Language_Compile_compilingUnit;
		TLINCL();
		(*sy).loc.base = 2;
		TLINCL();
		(*sy).loc.indir = 1;
		TLINCL();
		(*sy).u.__u1.__u4.fFormalsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u4.fImportsOf = (struct Language_Compile_ImportDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u4.ResultsId = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u4.ResultType = (struct Language_Compile_TypeDef *) 0;
	    }
	    break;
	case 6:
	    {
		TLSETL(100184);
		(*sy).loc.unitPtr = Language_Compile_compilingUnit;
		TLINCL();
		(*sy).loc.base = 2;
		TLINCL();
		(*sy).loc.indir = 1;
		TLINCL();
		(*sy).u.__u1.__u5.pFormalsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u5.pImportsOf = (struct Language_Compile_ImportDef *) 0;
		TLINCL();
		(*sy).u.__u1.__u5.pValue = Language_Compile_nonCompileTimeValue;
	    }
	    break;
	case 9:
	    {
		TLSETL(100192);
		(*sy).u.__u1.__u6.unionNumber = 0;
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

static void Language_Compile_Symbol_AddAutoImport (importSy)
struct Language_Compile_SymbolDef	*importSy;
{
    struct Language_Compile_ImportDef	*ni;
    register struct Language_Compile_ImportDef	*im;
    TLSTKCHKSLF(100200);
    TLSETF();
    TLSETL(100200);
    TLPRE ((importSy->importDepth) < Language_Compile_currentImportDepth);
    TLSETL(100204);
    Language_Compile_Memory_Allocate(&(ni), (TLint2) sizeof(struct Language_Compile_ImportDef));
    im = ni;
    TLSETL(100206);
    im->sy = importSy;
    TLINCL();
    im->newAccess = importSy->access;
    TLINCL();
    im->oldAccess = importSy->access;
    TLINCL();
    im->oldImportDepth = importSy->importDepth;
    TLINCL();
    im->overridesExpand = 0;
    TLINCL();
    importSy->importDepth = Language_Compile_currentImportDepth;
    TLSETL(100213);
    switch (Language_Compile_subprogramSymbol->u.syTag) {
	case 4:
	    {
		TLSETL(100215);
		im->next = Language_Compile_subprogramSymbol->u.__u1.__u4.fImportsOf;
		TLINCL();
		Language_Compile_subprogramSymbol->u.__u1.__u4.fImportsOf = im;
	    }
	    break;
	case 6:
	    {
		TLSETL(100218);
		im->next = Language_Compile_subprogramSymbol->u.__u1.__u5.pImportsOf;
		TLINCL();
		Language_Compile_subprogramSymbol->u.__u1.__u5.pImportsOf = im;
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_PushIdent (identPtr)
struct Language_Compile_IdentDef	*identPtr;
{
    struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100227);
    TLSETF();
    TLSETL(100227);
    sy = Language_Compile_Scope_IdentInScope(identPtr);
    TLINCL();
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLBINDREG((*bc), struct Language_Compile_BlockDef);
	TLSETL(100232);
	{
	    TLstring	__x2564;
	    Language_Compile_IdentToName(identPtr, __x2564);
	    Language_Compile_CompileError_Add((TLint2) 10288, &(Language_Compile_oldTok.srcPos), __x2564, "", (Language_ErrorSeverity) 2);
	};
	TLINCL();
	Language_Compile_Symbol_PushNamedNew(identPtr);
	Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.syTag = 0;
	TLSETL(100236);
	bc = &((*(Language_Compile_blockStack)));
	TLINCL();
	sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
	TLINCL();
	sy->next = (*bc).internalSymbols;
	TLINCL();
	(*bc).internalSymbols = sy;
	TLSETL(100241);
	TLRESTORELF();
	return;
    };
    TLSETL(100242);
    if (((sy->u.syTag) == 3) && ((sy->access) == 0)) {
	TLSETL(100246);
	{
	    TLstring	__x2565;
	    Language_Compile_SymbolToName(sy, __x2565);
	    Language_Compile_CompileError_Add((TLint2) 10221, &(Language_Compile_oldTok.srcPos), __x2565, "", (Language_ErrorSeverity) 2);
	};
    };
    TLSETL(100247);
    if ((sy->importDepth) < Language_Compile_currentImportDepth) {
	TLSETL(100248);
	if (((Language_Compile_subprogramSymbol != ((struct Language_Compile_SymbolDef *) 0)) && (((sy->importDepth) + 1) == Language_Compile_currentImportDepth)) && ((TLSMLSETCONST(0) & (Language_Compile_subprogramSymbol->attributes)) != 0)) {
	    TLSETL(100253);
	    Language_Compile_Symbol_AddAutoImport(sy);
	} else {
	    TLSETL(100256);
	    {
		TLstring	__x2566;
		Language_Compile_SymbolToName(sy, __x2566);
		Language_Compile_CompileError_Add((TLint2) 10290, &(Language_Compile_oldTok.srcPos), __x2566, "", (Language_ErrorSeverity) 1);
	    };
	};
    };
    TLSETL(100259);
    Language_Compile_Symbol_PushSymbol(sy);
    TLRESTORELF();
}

void Language_Compile_Symbol_PushPointerTarget () {
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100263);
    TLSETF();
    TLSETL(100263);
    sy = Language_Compile_Types_NameOf();
    TLINCL();
    TLASSERT (sy != ((struct Language_Compile_SymbolDef *) 0));
    TLSETL(100289);
    Language_Compile_Symbol_PushSymbol(sy);
    TLRESTORELF();
}

void Language_Compile_Symbol_PushDummy (kind)
Language_Compile_SymbolKind	kind;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100293);
    TLSETF();
    TLSETL(100293);
    sy = Language_Compile_Symbol_freeSymbolChain;
    TLINCL();
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	struct Language_Compile_SymbolDef	*ns;
	TLSETL(100297);
	Language_Compile_Memory_Allocate(&(ns), (TLint2) sizeof(struct Language_Compile_SymbolDef));
	sy = ns;
    } else {
	TLSETL(100299);
	Language_Compile_Symbol_freeSymbolChain = sy->next;
    };
    TLSETL(100302);
    sy->next = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    sy->identPtr = (struct Language_Compile_IdentDef *) 0;
    TLINCL();
    sy->tyPtr = Language_Compile_Types_Top();
    TLINCL();
    sy->importDepth = 0;
    TLINCL();
    sy->predefined = 0;
    TLINCL();
    sy->attributes = 0x20;
    TLINCL();
    sy->definingSy = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    sy->blockScope = (struct Language_Compile_BlockDef *) 0;
    TLINCL();
    TLSTRCTASS(sy->loc, Language_Compile_nullLocation, struct Language_Compile_Location);
    TLSETL(100312);
    TLSTRCTASS(sy->srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    sy->definingOffset = 0;
    TLSETL(100316);
    sy->u.syTag = kind;
    TLINCL();
    switch (kind) {
	case 0:
	    {
		TLSETL(100319);
		sy->access = 0;
	    }
	    break;
	case 3:
	    {
		TLSETL(100321);
		sy->access = 1;
		TLINCL();
		sy->attributes |= 0x1000;
		TLSETL(100324);
		sy->u.__u1.__u3.cValue = Language_Compile_Value_Top();
	    }
	    break;
	case 4:
	    {
		TLSETL(100326);
		sy->access = 1;
		TLINCL();
		sy->u.__u1.__u4.fFormalsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		sy->u.__u1.__u4.ResultsId = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		sy->u.__u1.__u4.ResultType = (struct Language_Compile_TypeDef *) 0;
	    }
	    break;
	case 6:
	    {
		TLSETL(100331);
		sy->access = 1;
		TLINCL();
		sy->u.__u1.__u5.pFormalsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		sy->u.__u1.__u5.pValue = Language_Compile_nonCompileTimeValue;
	    }
	    break;
	case 8:
	    {
		TLSETL(100335);
		sy->access = 1;
		TLINCL();
		sy->u.syTag = 8;
	    }
	    break;
	case 9:
	    {
		TLSETL(100338);
		sy->access = 2;
		TLINCL();
		sy->u.syTag = 9;
		TLINCL();
		sy->u.__u1.__u6.unionNumber = 0;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100344);
    Language_Compile_Symbol_PushSymbol(sy);
    TLRESTORELF();
}

void Language_Compile_Symbol_ReplaceDummy (kind)
Language_Compile_SymbolKind	kind;
{
    struct Language_Compile_SymbolDef	*topSy;
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100348);
    TLSETF();
    TLSETL(100348);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    topSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    sy = Language_Compile_Symbol_freeSymbolChain;
    TLINCL();
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	struct Language_Compile_SymbolDef	*ns;
	TLSETL(100354);
	Language_Compile_Memory_Allocate(&(ns), (TLint2) sizeof(struct Language_Compile_SymbolDef));
	sy = ns;
    } else {
	TLSETL(100356);
	Language_Compile_Symbol_freeSymbolChain = sy->next;
    };
    TLSETL(100359);
    sy->next = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    sy->identPtr = topSy->identPtr;
    TLINCL();
    sy->tyPtr = Language_Compile_Types_Top();
    TLINCL();
    sy->importDepth = 0;
    TLINCL();
    sy->predefined = 0;
    TLINCL();
    sy->attributes = (topSy->attributes) | ((TLSMLSETCONST(5)));
    TLSETL(100366);
    sy->definingSy = topSy->definingSy;
    TLSETL(100369);
    TLSTRCTASS(sy->loc, topSy->loc, struct Language_Compile_Location);
    TLSETL(100371);
    TLSTRCTASS(sy->srcPos, topSy->srcPos, struct SrcPosition);
    TLINCL();
    sy->definingOffset = topSy->definingOffset;
    TLSETL(100375);
    switch (kind) {
	case 0:
	    {
		TLSETL(100377);
		sy->access = 0;
		TLINCL();
		sy->u.syTag = 0;
	    }
	    break;
	case 2:
	    {
		TLSETL(100380);
		sy->access = topSy->access;
		TLINCL();
		sy->u.syTag = 2;
	    }
	    break;
	case 3:
	    {
		TLSETL(100383);
		sy->access = 1;
		TLINCL();
		sy->u.syTag = 3;
		TLINCL();
		sy->u.__u1.__u3.cValue = Language_Compile_Value_Top();
	    }
	    break;
	case 7:
	    {
		TLSETL(100387);
		sy->access = 1;
		TLINCL();
		sy->u.syTag = 7;
	    }
	    break;
	case 8:
	    {
		TLSETL(100390);
		sy->access = 1;
		TLINCL();
		sy->u.syTag = 8;
	    }
	    break;
	case 9:
	    {
		TLSETL(100393);
		sy->access = topSy->access;
		TLINCL();
		sy->u.syTag = 9;
		TLINCL();
		sy->u.__u1.__u6.unionNumber = 0;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100399);
    Language_Compile_Symbol_Pop();
    TLINCL();
    Language_Compile_Symbol_PushSymbol(sy);
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterBlockScope () {
    TLSTKCHKSLF(100404);
    TLSETF();
    TLSETL(100404);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->blockScope = Language_Compile_blockStack;
    TLRESTORELF();
}

struct Language_Compile_BlockDef * Language_Compile_Symbol_BlockScope () {
    TLSTKCHKSLF(100410);
    TLSETF();
    TLSETL(100410);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->blockScope);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ExpandSy () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100416);
    TLSETF();
    TLSETL(100416);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(100420);
		TLRESTORELF();
		return ((*sy).u.__u1.__u2.mExpandSy);
	    }
	    break;
	default :
	    {
		TLSETL(100422);
		TLRESTORELF();
		return ((struct Language_Compile_SymbolDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_ImportDef * Language_Compile_Symbol_ImportsOf () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100428);
    TLSETF();
    TLSETL(100428);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(100432);
		TLRESTORELF();
		return ((*sy).u.__u1.__u2.mImportsOf);
	    }
	    break;
	case 4:
	    {
		TLSETL(100434);
		TLRESTORELF();
		return ((*sy).u.__u1.__u4.fImportsOf);
	    }
	    break;
	case 6:
	    {
		TLSETL(100436);
		TLRESTORELF();
		return ((*sy).u.__u1.__u5.pImportsOf);
	    }
	    break;
	default :
	    {
		TLSETL(100438);
		TLRESTORELF();
		return ((struct Language_Compile_ImportDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_ClearSubprogramImports () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100444);
    TLSETF();
    TLSETL(100444);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 4:
	    {
		TLSETL(100448);
		(*sy).u.__u1.__u4.fImportsOf = (struct Language_Compile_ImportDef *) 0;
	    }
	    break;
	case 6:
	    {
		TLSETL(100450);
		(*sy).u.__u1.__u5.pImportsOf = (struct Language_Compile_ImportDef *) 0;
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportsOf () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100457);
    TLSETF();
    TLSETL(100457);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(100461);
		TLRESTORELF();
		return ((*sy).u.__u1.__u2.mExportsOf);
	    }
	    break;
	default :
	    {
		TLSETL(100463);
		TLRESTORELF();
		return ((struct Language_Compile_ExportDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_ExportDef * Language_Compile_Symbol_ExportedIdent (id, moduleSy)
struct Language_Compile_IdentDef	*id;
struct Language_Compile_SymbolDef	*moduleSy;
{
    TLSTKCHKSLF(100470);
    TLSETF();
    TLSETL(100470);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    if (moduleSy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(100472);
	TLRESTORELF();
	return ((struct Language_Compile_ExportDef *) 0);
    };
    TLSETL(100474);
    switch (moduleSy->u.syTag) {
	case 1:
	case 5:
	    break;
	default :
	    {
		TLSETL(100477);
		TLRESTORELF();
		return ((struct Language_Compile_ExportDef *) 0);
	    }
	    break;
    };
    TLSETL(100479);
    TLRESTORELF();
    return (Language_Compile_Scope_IdentInExportList(id, moduleSy->u.__u1.__u2.mExportsOf));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_FixImportedSymbols (scopeSy)
struct Language_Compile_SymbolDef	*scopeSy;
{
    register struct Language_Compile_ImportDef	*im;
    TLSTKCHKSLF(100485);
    TLSETF();
    TLSETL(100485);
    switch (scopeSy->u.syTag) {
	case 1:
	case 5:
	    {
		struct Language_Compile_SymbolDef	*expandSy;
		TLSETL(100487);
		expandSy = scopeSy->u.__u1.__u2.mExpandSy;
		TLINCL();
		if (expandSy != ((struct Language_Compile_SymbolDef *) 0)) {
		    TLSETL(100490);
		    Language_Compile_Symbol_FixImportedSymbols(expandSy);
		};
		TLSETL(100491);
		im = scopeSy->u.__u1.__u2.mImportsOf;
	    }
	    break;
	case 4:
	    {
		TLSETL(100493);
		im = scopeSy->u.__u1.__u4.fImportsOf;
	    }
	    break;
	case 6:
	    {
		TLSETL(100495);
		im = scopeSy->u.__u1.__u5.pImportsOf;
	    }
	    break;
	default :
	    {
		TLSETL(100498);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLSETL(100500);
    for(;;) {
	struct Language_Compile_SymbolDef	*sy;
	TLSETL(100500);
	if (im == ((struct Language_Compile_ImportDef *) 0)) {
	    break;
	};
	TLSETL(100501);
	sy = im->sy;
	TLINCL();
	if (im->overridesExpand) {
	    struct Language_Compile_SymbolDef	*expandSy;
	    TLSETL(100503);
	    expandSy = scopeSy->u.__u1.__u2.mExpandSy;
	    TLSETL(100505);
	    for(;;) {
		register struct Language_Compile_ImportDef	*expandIm;
		TLSETL(100505);
		expandIm = expandSy->u.__u1.__u2.mImportsOf;
		TLSETL(100508);
		for(;;) {
		    TLSETL(100508);
		    if (expandIm == ((struct Language_Compile_ImportDef *) 0)) {
			break;
		    };
		    TLSETL(100509);
		    if ((expandIm->sy) == sy) {
			TLSETL(100510);
			TLASSERT ((expandIm->oldAccess) != 0);
			TLINCL();
			sy->access = expandIm->oldAccess;
			TLINCL();
			sy->importDepth = expandIm->oldImportDepth;
			TLSETL(100514);
			expandIm->oldAccess = 0;
			TLSETL(100516);
			break;
		    };
		    TLSETL(100517);
		    expandIm = expandIm->next;
		};
		TLSETL(100519);
		if (expandIm != ((struct Language_Compile_ImportDef *) 0)) {
		    break;
		};
		TLSETL(100520);
		expandSy = expandSy->u.__u1.__u2.mExpandSy;
		TLINCL();
		TLASSERT (expandSy != ((struct Language_Compile_SymbolDef *) 0));
	    };
	};
	TLSETL(100524);
	im->oldAccess = sy->access;
	TLINCL();
	sy->access = im->newAccess;
	TLINCL();
	im->oldImportDepth = sy->importDepth;
	TLINCL();
	if ((sy->importDepth) != 255) {
	    TLSETL(100528);
	    sy->importDepth = Language_Compile_currentImportDepth + 1;
	};
	TLSETL(100530);
	im = im->next;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_AddImport (access, explicitAccess)
Language_Compile_Access	access;
TLboolean	explicitAccess;
{
    register struct Language_Compile_SymbolDef	*scopeSy;
    register struct Language_Compile_SymbolDef	*importSy;
    struct Language_Compile_SymbolDef	*expandSy;
    register struct Language_Compile_ImportDef	*im;
    TLboolean	overridesExpand;
    Language_Compile_Access	newAccess;
    struct Language_Compile_ImportDef	*ni;
    TLSTKCHKSLF(100536);
    TLSETF();
    TLSETL(100536);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    scopeSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)];
    TLINCL();
    importSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    expandSy = (struct Language_Compile_SymbolDef *) 0;
    TLSETL(100542);
    switch (scopeSy->u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(100544);
		im = scopeSy->u.__u1.__u2.mImportsOf;
		TLINCL();
		expandSy = scopeSy->u.__u1.__u2.mExpandSy;
	    }
	    break;
	case 4:
	    {
		TLSETL(100547);
		im = scopeSy->u.__u1.__u4.fImportsOf;
	    }
	    break;
	case 6:
	    {
		TLSETL(100549);
		im = scopeSy->u.__u1.__u5.pImportsOf;
	    }
	    break;
	default :
	    {
		TLSETL(100552);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLSETL(100558);
    for(;;) {
	TLSETL(100558);
	if (im == ((struct Language_Compile_ImportDef *) 0)) {
	    break;
	};
	TLSETL(100559);
	if ((im->sy) == importSy) {
	    TLSETL(100562);
	    {
		TLstring	__x2567;
		Language_Compile_SymbolToName(importSy, __x2567);
		Language_Compile_CompileError_Add((TLint2) 10127, &(Language_Compile_oldTok.srcPos), __x2567, "", (Language_ErrorSeverity) 1);
	    };
	    TLINCL();
	    TLRESTORELF();
	    return;
	} else {
	    TLSETL(100563);
	    if ((im->sy->identPtr) == (importSy->identPtr)) {
		TLSETL(100567);
		{
		    TLstring	__x2568;
		    Language_Compile_SymbolToName(importSy, __x2568);
		    Language_Compile_CompileError_Add((TLint2) 10126, &(Language_Compile_oldTok.srcPos), __x2568, "", (Language_ErrorSeverity) 2);
		};
		TLINCL();
		TLRESTORELF();
		return;
	    };
	};
	TLSETL(100569);
	im = im->next;
    };
    TLSETL(100576);
    overridesExpand = 0;
    TLINCL();
    if (expandSy != ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(100579);
	for(;;) {
	    TLSETL(100579);
	    scopeSy = scopeSy->u.__u1.__u2.mExpandSy;
	    TLINCL();
	    if (scopeSy == ((struct Language_Compile_SymbolDef *) 0)) {
		break;
	    };
	    TLSETL(100581);
	    im = scopeSy->u.__u1.__u2.mImportsOf;
	    TLSETL(100583);
	    for(;;) {
		TLSETL(100583);
		if (im == ((struct Language_Compile_ImportDef *) 0)) {
		    break;
		};
		TLSETL(100584);
		if ((im->sy) == importSy) {
		    TLSETL(100585);
		    TLASSERT ((im->oldAccess) != 0);
		    TLINCL();
		    importSy->access = im->oldAccess;
		    TLINCL();
		    importSy->importDepth = im->oldImportDepth;
		    TLSETL(100589);
		    im->oldAccess = 0;
		    TLINCL();
		    overridesExpand = 1;
		    TLSETL(100592);
		    break;
		} else {
		    TLSETL(100592);
		    if ((im->sy->identPtr) == (importSy->identPtr)) {
			TLSETL(100597);
			{
			    TLstring	__x2570;
			    Language_Compile_SymbolToName(scopeSy, __x2570);
			    {
				TLstring	__x2569;
				Language_Compile_SymbolToName(importSy, __x2569);
				Language_Compile_CompileError_Add((TLint2) 10125, &(Language_Compile_oldTok.srcPos), __x2569, __x2570, (Language_ErrorSeverity) 2);
			    };
			};
			TLINCL();
			TLRESTORELF();
			return;
		    };
		};
		TLSETL(100599);
		im = im->next;
	    };
	    TLSETL(100601);
	    if (overridesExpand) {
		break;
	    };
	};
	TLSETL(100603);
	scopeSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)];
    };
    TLSETL(100610);
    newAccess = access;
    TLINCL();
    if (newAccess == 2) {
	TLSETL(100612);
	switch (importSy->u.syTag) {
	    case 1:
	    case 2:
	    case 5:
	    case 9:
		{
		    TLSETL(100615);
		    if ((importSy->access) == 1) {
			TLSETL(100616);
			if (explicitAccess) {
			    TLSETL(100620);
			    {
				TLstring	__x2571;
				Language_Compile_SymbolToName(importSy, __x2571);
				Language_Compile_CompileError_Add((TLint2) 10235, &(Language_Compile_oldTok.srcPos), __x2571, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100621);
			newAccess = 1;
		    };
		}
		break;
	    case 0:
		break;
	    default :
		{
		    TLSETL(100625);
		    if (explicitAccess) {
			TLSETL(100628);
			Language_Compile_CompileError_Add((TLint2) 10304, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 2);
		    };
		    TLSETL(100629);
		    newAccess = 1;
		}
		break;
	};
    };
    TLSETL(100632);
    if ((importSy->u.syTag) == 2) {
	TLSETL(100634);
	Language_Compile_Types_PushType(importSy->tyPtr);
	TLINCL();
	Language_Compile_Types_ReplacePointerType((TLboolean) 0);
	if (Language_Compile_Types_UnresolvedCollection()) {
	    TLSETL(100638);
	    {
		TLstring	__x2572;
		Language_Compile_SymbolToName(importSy, __x2572);
		Language_Compile_CompileError_Add((TLint2) 10297, &(Language_Compile_oldTok.srcPos), __x2572, "", (Language_ErrorSeverity) 2);
	    };
	};
	TLSETL(100640);
	Language_Compile_Types_Pop();
    };
    TLSETL(100648);
    Language_Compile_Memory_Allocate(&(ni), (TLint2) sizeof(struct Language_Compile_ImportDef));
    im = ni;
    TLSETL(100650);
    im->sy = importSy;
    TLINCL();
    im->newAccess = newAccess;
    TLINCL();
    im->oldAccess = importSy->access;
    TLINCL();
    importSy->access = newAccess;
    TLINCL();
    im->oldImportDepth = importSy->importDepth;
    TLINCL();
    if ((importSy->importDepth) != 255) {
	TLSETL(100656);
	importSy->importDepth = Language_Compile_currentImportDepth + 1;
    };
    TLSETL(100658);
    im->overridesExpand = overridesExpand;
    TLSETL(100660);
    switch (scopeSy->u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(100662);
		im->next = scopeSy->u.__u1.__u2.mImportsOf;
		TLINCL();
		scopeSy->u.__u1.__u2.mImportsOf = im;
	    }
	    break;
	case 4:
	    {
		TLSETL(100665);
		im->next = scopeSy->u.__u1.__u4.fImportsOf;
		TLINCL();
		scopeSy->u.__u1.__u4.fImportsOf = im;
	    }
	    break;
	case 6:
	    {
		TLSETL(100668);
		im->next = scopeSy->u.__u1.__u5.pImportsOf;
		TLINCL();
		scopeSy->u.__u1.__u5.pImportsOf = im;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100676);
    if ((TLSMLSETCONST(10) & (importSy->attributes)) != 0) {
	register struct Language_Compile_ExportDef	*ex;
	TLSETL(100677);
	ex = importSy->u.__u1.__u2.mExportsOf;
	TLINCL();
	TLASSERT (ex != ((struct Language_Compile_ExportDef *) 0));
	TLSETL(100680);
	for(;;) {
	    TLSETL(100680);
	    if (((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) && ((ex->identPtr) != ((struct Language_Compile_IdentDef *) 0))) {
		register struct Language_Compile_SymbolDef	*exSy;
		TLSETL(100682);
		exSy = ex->symbolPtr;
		TLINCL();
		TLASSERT (exSy != ((struct Language_Compile_SymbolDef *) 0));
		TLINCL();
		Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)] = exSy;
		TLINCL();
		if (newAccess == 2) {
		    TLSETL(100687);
		    Language_Compile_Symbol_AddImport((Language_Compile_Access) (exSy->access), (TLboolean) 0);
		} else {
		    TLSETL(100689);
		    Language_Compile_Symbol_AddImport((Language_Compile_Access) newAccess, (TLboolean) 0);
		};
	    };
	    TLSETL(100691);
	    ex = ex->next;
	    TLINCL();
	    if (ex == ((struct Language_Compile_ExportDef *) 0)) {
		break;
	    };
	};
	TLSETL(100694);
	Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)] = importSy;
    };
    TLRESTORELF();
}

static void Language_Compile_Symbol_EnterExportList () {
    register struct Language_Compile_ExportDef	*ex;
    TLSTKCHKSLF(100700);
    TLSETF();
    TLSETL(100700);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    ex = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.__u1.__u2.mExportsOf;
    TLSETL(100703);
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u2.mExportsOf = ex;
    TLSETL(100705);
    for(;;) {
	register struct Language_Compile_SymbolDef	*sy;
	TLSETL(100705);
	if (ex == ((struct Language_Compile_ExportDef *) 0)) {
	    break;
	};
	TLSETL(100706);
	sy = ex->symbolPtr;
	TLINCL();
	if (sy != ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100708);
	    if ((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) {
		TLSETL(100709);
		TLASSERT ((sy->u.syTag) == 8);
		TLINCL();
		TLASSERT ((ex->opaqueTypePtr) == ((struct Language_Compile_TypeDef *) 0));
		TLSETL(100713);
		Language_Compile_Types_UnmakeTypeOpaque(sy->tyPtr, &(ex->opaqueTypePtr));
	    };
	    TLSETL(100714);
	    if ((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) {
		TLSETL(100715);
		Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->attributes |= 0x400;
	    };
	};
	TLSETL(100719);
	ex = ex->next;
    };
    TLRESTORELF();
}

static void Language_Compile_Symbol_AddExportToModule (id, kind, moduleSy)
struct Language_Compile_IdentDef	*id;
Language_Compile_ExportKindSet	kind;
struct Language_Compile_SymbolDef	*moduleSy;
{
    struct Language_Compile_ExportDef	*nx;
    register struct Language_Compile_ExportDef	*ex;
    TLSTKCHKSLF(100726);
    TLSETF();
    TLSETL(100726);
    if (id == ((struct Language_Compile_IdentDef *) 0)) {
	TLSETL(100728);
	TLRESTORELF();
	return;
    };
    TLSETL(100729);
    switch (moduleSy->u.syTag) {
	case 1:
	case 5:
	    break;
	default :
	    {
		TLSETL(100733);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLSETL(100737);
    Language_Compile_Memory_Allocate(&(nx), (TLint2) sizeof(struct Language_Compile_ExportDef));
    ex = nx;
    TLSETL(100739);
    ex->identPtr = id;
    TLINCL();
    ex->symbolPtr = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    ex->opaqueTypePtr = (struct Language_Compile_TypeDef *) 0;
    TLINCL();
    ex->kind = kind;
    TLINCL();
    ex->next = moduleSy->u.__u1.__u2.mExportsOf;
    TLINCL();
    moduleSy->u.__u1.__u2.mExportsOf = ex;
    TLSETL(100746);
    if ((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) {
	struct Language_Compile_SymbolDef	*idSy;
	TLSETL(100754);
	idSy = Language_Compile_Scope_IdentInImmediateScope(id, moduleSy->blockScope->parentBlock);
	TLSETL(100756);
	if (idSy == ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100757);
	    idSy = Language_Compile_Scope_IdentInImportList(id, moduleSy->definingSy);
	};
	TLSETL(100760);
	if (idSy != ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100763);
	    {
		TLstring	__x2573;
		Language_Compile_IdentToName(id, __x2573);
		Language_Compile_CompileError_Add((TLint2) 10296, &(Language_Compile_oldTok.srcPos), __x2573, "", (Language_ErrorSeverity) 2);
	    };
	    ex->kind &= ~ 0x4;
	} else {
	    TLSETL(100765);
	    moduleSy->attributes |= 0x400;
	};
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_AddExport (id, kind)
struct Language_Compile_IdentDef	*id;
Language_Compile_ExportKindSet	kind;
{
    TLSTKCHKSLF(100773);
    TLSETF();
    TLSETL(100773);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLSETL(100775);
    Language_Compile_Symbol_AddExportToModule(id, (Language_Compile_ExportKindSet) kind, Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]);
    TLRESTORELF();
}

void Language_Compile_Symbol_SetExportAll (kind)
Language_Compile_ExportKindSet	kind;
{
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(100779);
    TLSETF();
    TLSETL(100779);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    break;
	default :
	    {
		TLSETL(100785);
		TLRESTORELF();
		return;
	    }
	    break;
    };
    TLINCL();
    (*sy).u.__u1.__u2.mExportAllKind = kind;
    TLINCL();
    (*sy).attributes |= 0x40;
    TLRESTORELF();
}

void Language_Compile_Symbol_ResolveExport () {
    register struct Language_Compile_SymbolDef	*sy;
    register struct Language_Compile_SymbolDef	*moduleSy;
    Language_Compile_Access	access;
    TLSTKCHKSLF(100792);
    TLSETF();
    TLSETL(100792);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    moduleSy = sy->definingSy;
    TLINCL();
    if (moduleSy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(100797);
	TLRESTORELF();
	return;
    };
    TLSETL(100798);
    access = sy->access;
    TLSETL(100800);
    for(;;) {
	TLboolean	exportAll;
	register struct Language_Compile_ExportDef	*ex;
	TLSETL(100800);
	switch (moduleSy->u.syTag) {
	    case 1:
	    case 5:
		break;
	    default :
		{
		    TLSETL(100804);
		    TLRESTORELF();
		    return;
		}
		break;
	};
	TLSETL(100806);
	exportAll = (TLSMLSETCONST(6) & (moduleSy->attributes)) != 0;
	TLSETL(100808);
	if (exportAll) {
	    TLSETL(100811);
	    Language_Compile_Symbol_AddExportToModule(sy->identPtr, (Language_Compile_ExportKindSet) (moduleSy->u.__u1.__u2.mExportAllKind), moduleSy);
	};
	TLSETL(100813);
	ex = Language_Compile_Symbol_ExportedIdent(sy->identPtr, moduleSy);
	TLSETL(100815);
	if ((ex == ((struct Language_Compile_ExportDef *) 0)) || ((ex->symbolPtr) != ((struct Language_Compile_SymbolDef *) 0))) {
	    TLSETL(100817);
	    TLRESTORELF();
	    return;
	};
	TLSETL(100819);
	switch (sy->u.syTag) {
	    case 1:
	    case 5:
	    case 9:
		{
		    TLSETL(100821);
		    if ((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) {
			TLSETL(100822);
			if (!exportAll) {
			    TLSETL(100826);
			    {
				TLstring	__x2574;
				Language_Compile_SymbolToName(moduleSy, __x2574);
				Language_Compile_CompileError_Add((TLint2) 10207, &(Language_Compile_oldTok.srcPos), __x2574, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100827);
			ex->kind &= ~ 0x1;
		    };
		    TLSETL(100829);
		    if (((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) && ((moduleSy->u.syTag) == 1)) {
			TLSETL(100831);
			if (!exportAll) {
			    TLSETL(100835);
			    {
				TLstring	__x2575;
				Language_Compile_SymbolToName(moduleSy, __x2575);
				Language_Compile_CompileError_Add((TLint2) 10123, &(Language_Compile_oldTok.srcPos), __x2575, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100836);
			ex->kind &= ~ 0x6;
		    };
		    TLSETL(100839);
		    if (((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) && (access != 2)) {
			TLSETL(100841);
			if (!exportAll) {
			    TLSETL(100846);
			    {
				TLstring	__x2577;
				Language_Compile_SymbolToName(moduleSy, __x2577);
				{
				    TLstring	__x2576;
				    Language_Compile_SymbolToName(sy, __x2576);
				    Language_Compile_CompileError_Add((TLint2) 10233, &(Language_Compile_oldTok.srcPos), __x2576, __x2577, (Language_ErrorSeverity) 1);
				};
			    };
			};
			TLSETL(100847);
			ex->kind &= ~ 0x8;
		    } else {
			TLSETL(100849);
			access = 1;
		    };
		    TLSETL(100851);
		    if (((moduleSy->u.syTag) == 1) && ((TLSMLSMLSETCONST(2) & (sy->tyPtr->mode)) != 0)) {
			TLSETL(100857);
			{
			    TLstring	__x2579;
			    Language_Compile_SymbolToName(moduleSy, __x2579);
			    {
				TLstring	__x2578;
				Language_Compile_SymbolToName(sy, __x2578);
				Language_Compile_CompileError_Add((TLint2) 10064, &(Language_Compile_oldTok.srcPos), __x2578, __x2579, (Language_ErrorSeverity) 2);
			    };
			};
		    };
		}
		break;
	    case 2:
		{
		    TLSETL(100859);
		    if ((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) {
			TLSETL(100860);
			if (!exportAll) {
			    TLSETL(100864);
			    {
				TLstring	__x2580;
				Language_Compile_SymbolToName(moduleSy, __x2580);
				Language_Compile_CompileError_Add((TLint2) 10207, &(Language_Compile_oldTok.srcPos), __x2580, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100865);
			ex->kind &= ~ 0x1;
		    };
		    TLSETL(100867);
		    if (((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) && (access != 2)) {
			TLSETL(100869);
			if (!exportAll) {
			    TLSETL(100874);
			    {
				TLstring	__x2582;
				Language_Compile_SymbolToName(moduleSy, __x2582);
				{
				    TLstring	__x2581;
				    Language_Compile_SymbolToName(sy, __x2581);
				    Language_Compile_CompileError_Add((TLint2) 10233, &(Language_Compile_oldTok.srcPos), __x2581, __x2582, (Language_ErrorSeverity) 1);
				};
			    };
			};
			TLSETL(100875);
			ex->kind &= ~ 0x8;
		    } else {
			TLSETL(100877);
			access = 1;
		    };
		}
		break;
	    case 3:
		{
		    TLSETL(100880);
		    if ((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) {
			TLSETL(100881);
			if (!exportAll) {
			    TLSETL(100885);
			    {
				TLstring	__x2583;
				Language_Compile_SymbolToName(moduleSy, __x2583);
				Language_Compile_CompileError_Add((TLint2) 10207, &(Language_Compile_oldTok.srcPos), __x2583, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100886);
			ex->kind &= ~ 0x1;
		    };
		    TLSETL(100888);
		    if ((((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) && ((moduleSy->u.syTag) == 1)) && ((sy->u.__u1.__u3.cValue) == Language_Compile_nonCompileTimeValue)) {
			TLSETL(100891);
			if (!exportAll) {
			    TLSETL(100895);
			    {
				TLstring	__x2584;
				Language_Compile_SymbolToName(moduleSy, __x2584);
				Language_Compile_CompileError_Add((TLint2) 10123, &(Language_Compile_oldTok.srcPos), __x2584, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100896);
			ex->kind &= ~ 0x6;
		    };
		    TLSETL(100899);
		    if ((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) {
			TLSETL(100900);
			if (!exportAll) {
			    TLSETL(100904);
			    {
				TLstring	__x2585;
				Language_Compile_SymbolToName(moduleSy, __x2585);
				Language_Compile_CompileError_Add((TLint2) 10303, &(Language_Compile_oldTok.srcPos), __x2585, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100905);
			ex->kind &= ~ 0x8;
		    };
		}
		break;
	    case 4:
	    case 6:
		{
		    TLSETL(100908);
		    if ((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) {
			TLSETL(100909);
			if (!exportAll) {
			    TLSETL(100913);
			    {
				TLstring	__x2586;
				Language_Compile_SymbolToName(moduleSy, __x2586);
				Language_Compile_CompileError_Add((TLint2) 10207, &(Language_Compile_oldTok.srcPos), __x2586, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100914);
			ex->kind &= ~ 0x1;
		    };
		    TLSETL(100916);
		    if (((TLSMLSMLSETCONST(2) & (ex->kind)) != 0) && ((moduleSy->u.syTag) == 1)) {
			TLSETL(100918);
			if (!exportAll) {
			    TLSETL(100922);
			    {
				TLstring	__x2587;
				Language_Compile_SymbolToName(moduleSy, __x2587);
				Language_Compile_CompileError_Add((TLint2) 10123, &(Language_Compile_oldTok.srcPos), __x2587, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100923);
			ex->kind &= ~ 0x6;
		    };
		    TLSETL(100926);
		    if ((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) {
			TLSETL(100927);
			if (!exportAll) {
			    TLSETL(100931);
			    {
				TLstring	__x2588;
				Language_Compile_SymbolToName(moduleSy, __x2588);
				Language_Compile_CompileError_Add((TLint2) 10303, &(Language_Compile_oldTok.srcPos), __x2588, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100932);
			ex->kind &= ~ 0x8;
		    };
		    TLSETL(100934);
		    if ((moduleSy->u.__u1.__u2.mClassTagSy) != ((struct Language_Compile_SymbolDef *) 0)) {
			TLSETL(100935);
			sy->attributes |= 0x8;
		    };
		    TLSETL(100938);
		    if ((TLSMLSETCONST(13) & (moduleSy->attributes)) != 0) {
			TLSETL(100939);
			sy->attributes |= 0x4000;
		    };
		}
		break;
	    case 8:
		{
		    TLSETL(100943);
		    if ((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) {
			TLSETL(100944);
			if (!exportAll) {
			    TLSETL(100948);
			    {
				TLstring	__x2589;
				Language_Compile_SymbolToName(moduleSy, __x2589);
				Language_Compile_CompileError_Add((TLint2) 10303, &(Language_Compile_oldTok.srcPos), __x2589, "", (Language_ErrorSeverity) 1);
			    };
			};
			TLSETL(100949);
			ex->kind &= ~ 0x8;
		    };
		}
		break;
	    default :
		{
		    TLSETL(100952);
		    if (!exportAll) {
			TLSETL(100955);
			Language_Compile_CompileError_Add((TLint2) 10142, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 2);
		    };
		    TLSETL(100956);
		    ex->identPtr = (struct Language_Compile_IdentDef *) 0;
		    TLSETL(100958);
		    TLRESTORELF();
		    return;
		}
		break;
	};
	TLSETL(100960);
	ex->symbolPtr = sy;
	TLSETL(100962);
	moduleSy = moduleSy->definingSy;
	TLINCL();
	if (moduleSy == ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100964);
	    sy->attributes |= 0x80;
	    TLSETL(100966);
	    break;
	};
	TLSETL(100968);
	if ((TLSMLSMLSETCONST(2) & (ex->kind)) == 0) {
	    break;
	};
    };
    TLRESTORELF();
}

static void Language_Compile_Symbol_ResetExportList (list)
struct Language_Compile_ExportDef	*list;
{
    register struct Language_Compile_ExportDef	*ex;
    TLSTKCHKSLF(100974);
    TLSETF();
    TLSETL(100974);
    ex = list;
    TLSETL(100976);
    for(;;) {
	register struct Language_Compile_SymbolDef	*sy;
	TLSETL(100976);
	if (ex == ((struct Language_Compile_ExportDef *) 0)) {
	    break;
	};
	TLSETL(100978);
	sy = ex->symbolPtr;
	TLINCL();
	if (sy != ((struct Language_Compile_SymbolDef *) 0)) {
	    TLSETL(100980);
	    if (((TLSMLSMLSETCONST(0) & (ex->kind)) != 0) && ((ex->opaqueTypePtr) != ((struct Language_Compile_TypeDef *) 0))) {
		TLSETL(100983);
		TLASSERT ((sy->u.syTag) == 8);
		TLSETL(100986);
		Language_Compile_Types_MakeTypeOpaque(sy->tyPtr, ex->opaqueTypePtr);
		ex->opaqueTypePtr = (struct Language_Compile_TypeDef *) 0;
	    };
	    TLSETL(100988);
	    if ((TLSMLSMLSETCONST(1) & (ex->kind)) != 0) {
		TLSETL(100989);
		sy->importDepth = 255;
	    } else {
		TLSETL(100991);
		sy->importDepth = Language_Compile_currentImportDepth + 1;
	    };
	    TLSETL(100993);
	    if ((TLSMLSMLSETCONST(3) & (ex->kind)) != 0) {
		TLSETL(100994);
		sy->access = 2;
	    } else {
		TLSETL(100996);
		sy->access = 1;
	    };
	};
	TLSETL(101000);
	ex = ex->next;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_ResetSymbolList (list)
struct Language_Compile_SymbolDef	*list;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(101006);
    TLSETF();
    TLSETL(101006);
    sy = list;
    TLSETL(101008);
    for(;;) {
	TLSETL(101008);
	if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	    break;
	};
	TLSETL(101010);
	switch (sy->u.syTag) {
	    case 1:
	    case 5:
		{
		    TLSETL(101012);
		    sy->access = 2;
		    TLSETL(101014);
		    Language_Compile_Symbol_ResetExportList(sy->u.__u1.__u2.mExportsOf);
		}
		break;
	    case 2:
	    case 9:
		{
		    TLSETL(101015);
		    sy->access = 2;
		}
		break;
	    case 3:
	    case 4:
	    case 6:
	    case 8:
		{
		    TLSETL(101018);
		    sy->access = 1;
		}
		break;
	    default :
		{
		    TLSETL(101020);
		    sy->access = 0;
		}
		break;
	};
	TLSETL(101023);
	if ((TLSMLSETCONST(17) & (sy->attributes)) != 0) {
	    TLSETL(101024);
	    sy->importDepth = 255;
	} else {
	    TLSETL(101026);
	    sy->importDepth = Language_Compile_currentImportDepth + 1;
	};
	TLSETL(101029);
	sy = sy->next;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterExpand (implements)
TLboolean	implements;
{
    register struct Language_Compile_SymbolDef	*moduleSy;
    register struct Language_Compile_SymbolDef	*expandSy;
    TLSTKCHKSLF(101035);
    TLSETF();
    TLSETL(101035);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    moduleSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)];
    TLINCL();
    expandSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    TLASSERT ((expandSy->u.syTag) == (moduleSy->u.syTag));
    TLINCL();
    moduleSy->u.__u1.__u2.mExpandSy = expandSy;
    TLINCL();
    moduleSy->u.__u1.__u2.mMonitorVar = expandSy->u.__u1.__u2.mMonitorVar;
    TLINCL();
    moduleSy->u.__u1.__u2.mClassTagSy = expandSy->u.__u1.__u2.mClassTagSy;
    TLINCL();
    moduleSy->u.__u1.__u2.mDeferredNum = expandSy->u.__u1.__u2.mDeferredNum;
    TLSETL(101044);
    if (implements) {
	TLSETL(101045);
	moduleSy->attributes |= 0x800;
    };
    TLSETL(101052);
    Language_Compile_blockStack->expandBlock = expandSy->blockScope;
    TLSETL(101058);
    for(;;) {
	TLSETL(101060);
	Language_Compile_Symbol_ResetSymbolList(expandSy->blockScope->internalSymbols);
	expandSy = expandSy->u.__u1.__u2.mExpandSy;
	TLINCL();
	if (expandSy == ((struct Language_Compile_SymbolDef *) 0)) {
	    break;
	};
    };
    TLSETL(101068);
    Language_Compile_Symbol_FixImportedSymbols(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]);
    TLINCL();
    Language_Compile_Symbol_EnterExportList();
    TLRESTORELF();
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_MonitorVar () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101073);
    TLSETF();
    TLSETL(101073);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(101077);
		TLRESTORELF();
		return ((*sy).u.__u1.__u2.mMonitorVar);
	    }
	    break;
	default :
	    {
		TLSETL(101079);
		TLRESTORELF();
		return ((struct Language_Compile_SymbolDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_EnterMonitorVar () {
    TLSTKCHKSLF(101085);
    TLSETF();
    TLSETL(101085);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    TLASSERT ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u2.mMonitorVar) == ((struct Language_Compile_SymbolDef *) 0));
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u2.mMonitorVar = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLRESTORELF();
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ClassTagSy () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101093);
    TLSETF();
    TLSETL(101093);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(101097);
		TLRESTORELF();
		return ((*sy).u.__u1.__u2.mClassTagSy);
	    }
	    break;
	default :
	    {
		TLSETL(101099);
		TLRESTORELF();
		return ((struct Language_Compile_SymbolDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_EnterClassTag () {
    TLSTKCHKSLF(101105);
    TLSETF();
    TLSETL(101105);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    TLASSERT ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u2.mClassTagSy) == ((struct Language_Compile_SymbolDef *) 0));
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u2.mClassTagSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterFormals (formal)
struct Language_Compile_SymbolDef	*formal;
{
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101113);
    TLSETF();
    TLSETL(101113);
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 6:
	    {
		TLSETL(101116);
		(*sy).u.__u1.__u5.pFormalsOf = formal;
	    }
	    break;
	case 4:
	    {
		TLSETL(101118);
		(*sy).u.__u1.__u4.fFormalsOf = formal;
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterLocation (loc)
struct Language_Compile_Location	*loc;
{
    TLSTKCHKSLF(101125);
    TLSETF();
    TLSETL(101125);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLSTRCTASS(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->loc, (*loc), struct Language_Compile_Location);
    TLRESTORELF();
}

void Language_Compile_Symbol_AddDeferredLocation (loc)
struct Language_Compile_Location	*loc;
{
    struct Language_Compile_SymbolDef	*modSy;
    struct Language_Compile_DeferredLocDef	*nd;
    register struct Language_Compile_DeferredLocDef	*dl;
    TLSTKCHKSLF(101131);
    TLSETF();
    TLSETL(101131);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    modSy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)];
    TLSETL(101136);
    Language_Compile_Memory_Allocate(&(nd), (TLint2) sizeof(struct Language_Compile_DeferredLocDef));
    dl = nd;
    TLSETL(101138);
    dl->next = modSy->u.__u1.__u2.mDeferredLocs;
    TLINCL();
    modSy->u.__u1.__u2.mDeferredLocs = dl;
    TLSETL(101141);
    dl->sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    TLSTRCTASS(dl->loc, (*loc), struct Language_Compile_Location);
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterResultsId () {
    TLSTKCHKSLF(101147);
    TLSETF();
    TLSETL(101147);
    TLPRE ((Language_Compile_Symbol_symbolTop > 1) && ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.syTag) == 4));
    TLSETL(101149);
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.__u1.__u4.ResultsId = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLRESTORELF();
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_ResultsId () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101154);
    TLSETF();
    TLSETL(101154);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    if (((*sy).u.syTag) == 4) {
	TLSETL(101157);
	TLRESTORELF();
	return ((*sy).u.__u1.__u4.ResultsId);
    } else {
	TLSETL(101159);
	TLRESTORELF();
	return ((struct Language_Compile_SymbolDef *) 0);
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_EnterResultType () {
    TLSTKCHKSLF(101165);
    TLSETF();
    TLSETL(101165);
    TLPRE ((Language_Compile_Symbol_symbolTop > 0) && ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.syTag) == 4));
    TLSETL(101167);
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.__u1.__u4.ResultType = Language_Compile_Types_Top();
    TLRESTORELF();
}

struct Language_Compile_TypeDef * Language_Compile_Symbol_ResultType () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101172);
    TLSETF();
    TLSETL(101172);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    if (((*sy).u.syTag) == 4) {
	TLSETL(101175);
	TLRESTORELF();
	return ((*sy).u.__u1.__u4.ResultType);
    } else {
	TLSETL(101177);
	TLRESTORELF();
	return ((struct Language_Compile_TypeDef *) 0);
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_EnterValue (val)
struct Language_Compile_ValueDef	*val;
{
    TLSTKCHKSLF(101183);
    TLSETF();
    TLSETL(101183);
    TLPRE ((Language_Compile_Symbol_symbolTop > 0) && ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.syTag) == 3));
    TLSETL(101185);
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.__u1.__u3.cValue = val;
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterInterruptProcedureValue () {
    TLSTKCHKSLF(101190);
    TLSETF();
    TLSETL(101190);
    TLPRE ((Language_Compile_Symbol_symbolTop > 0) && ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.syTag) == 6));
    TLSETL(101192);
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.__u1.__u5.pValue = Language_Compile_Value_Top();
    TLRESTORELF();
}

void Language_Compile_Symbol_SetPervasive () {
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(101197);
    TLSETF();
    TLSETL(101197);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    sy->importDepth = 255;
    TLINCL();
    sy->attributes |= 0x20000;
    TLRESTORELF();
}

void Language_Compile_Symbol_EnterAttribute (attr)
Language_Compile_SyAttributes	attr;
{
    TLSTKCHKSLF(101205);
    TLSETF();
    TLSETL(101205);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->attributes |= (TLSMLSETCONST(TLINRANGELOW(attr, 0, 19, 19)));
    TLRESTORELF();
}

TLboolean Language_Compile_Symbol_HasAttribute (attr)
Language_Compile_SyAttributes	attr;
{
    TLSTKCHKSLF(101211);
    TLSETF();
    TLSETL(101211);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return ((TLSMLSETCONST(TLINRANGELOW(attr, 0, 19, 19)) & (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->attributes)) != 0);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_ClearAttribute (attr)
Language_Compile_SyAttributes	attr;
{
    TLSTKCHKSLF(101217);
    TLSETF();
    TLSETL(101217);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->attributes &= ~ (TLSMLSETCONST(TLINRANGELOW(attr, 0, 19, 19)));
    TLRESTORELF();
}

TLboolean Language_Compile_Symbol_IsDoubleIndirect () {
    TLSTKCHKSLF(101222);
    TLSETF();
    TLSETL(101222);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return ((Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->loc.indir) == 2);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_EnterType () {
    TLSTKCHKSLF(101228);
    TLSETF();
    TLSETL(101228);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->tyPtr = Language_Compile_Types_Top();
    TLRESTORELF();
}

struct Language_Compile_TypeDef * Language_Compile_Symbol_Type () {
    TLSTKCHKSLF(101234);
    TLSETF();
    TLSETL(101234);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->tyPtr);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_TypeDef * Language_Compile_Symbol_SecondType () {
    TLSTKCHKSLF(101240);
    TLSETF();
    TLSETL(101240);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->tyPtr);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_Predef Language_Compile_Symbol_Predefined () {
    TLSTKCHKSLF(101246);
    TLSETF();
    TLSETL(101246);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->predefined);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_ValueDef * Language_Compile_Symbol_SyValue () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101252);
    TLSETF();
    TLSETL(101252);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 3:
	    {
		TLSETL(101256);
		TLRESTORELF();
		return ((*sy).u.__u1.__u3.cValue);
	    }
	    break;
	case 6:
	    {
		TLSETL(101258);
		TLRESTORELF();
		return ((*sy).u.__u1.__u5.pValue);
	    }
	    break;
	default :
	    {
		TLSETL(101260);
		TLRESTORELF();
		return (Language_Compile_nonCompileTimeValue);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Top () {
    TLSTKCHKSLF(101266);
    TLSETF();
    TLSETL(101266);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Second () {
    TLSTKCHKSLF(101272);
    TLSETF();
    TLSETL(101272);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_Nth (nth)
TLint4	nth;
{
    TLSTKCHKSLF(101277);
    TLSETF();
    TLSETL(101277);
    TLPRE (Language_Compile_Symbol_symbolTop > nth);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - nth, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_SymbolKind Language_Compile_Symbol_Kind () {
    TLSTKCHKSLF(101282);
    TLSETF();
    TLSETL(101282);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->u.syTag);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_SymbolKind Language_Compile_Symbol_SecondKind () {
    TLSTKCHKSLF(101288);
    TLSETF();
    TLSETL(101288);
    TLPRE (Language_Compile_Symbol_symbolTop > 1);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop - 1, 1, 30, 1)]->u.syTag);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Symbol_FormalsOf () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101294);
    TLSETF();
    TLSETL(101294);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 4:
	    {
		TLSETL(101298);
		TLRESTORELF();
		return ((*sy).u.__u1.__u4.fFormalsOf);
	    }
	    break;
	case 6:
	    {
		TLSETL(101300);
		TLRESTORELF();
		return ((*sy).u.__u1.__u5.pFormalsOf);
	    }
	    break;
	default :
	    {
		TLSETL(101302);
		TLRESTORELF();
		return ((struct Language_Compile_SymbolDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_Access Language_Compile_Symbol_SyAccess () {
    TLSTKCHKSLF(101308);
    TLSETF();
    TLSETL(101308);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)]->access);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Symbol_SubprogramVariable () {
    TLBINDREG((*sy), struct Language_Compile_SymbolDef);
    TLSTKCHKSLF(101314);
    TLSETF();
    TLSETL(101314);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLINCL();
    sy = &((*(Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)])));
    TLINCL();
    switch ((*sy).u.syTag) {
	case 9:
	case 3:
	    {
		TLSETL(101318);
		TLRESTORELF();
		return ((((*sy).tyPtr->u.tyTag) == 22) || (((*sy).tyPtr->u.tyTag) == 15));
	    }
	    break;
	default :
	    {
		TLSETL(101321);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Symbol_Pop () {
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(101327);
    TLSETF();
    TLSETL(101327);
    TLPRE (Language_Compile_Symbol_symbolTop > 0);
    TLSETL(101329);
    sy = Language_Compile_Symbol_symbolStack[TLINRANGELOW(Language_Compile_Symbol_symbolTop, 1, 30, 1)];
    TLINCL();
    if ((TLSMLSETCONST(5) & (sy->attributes)) != 0) {
	TLSETL(101331);
	sy->next = Language_Compile_Symbol_freeSymbolChain;
	TLINCL();
	Language_Compile_Symbol_freeSymbolChain = sy;
    };
    TLSETL(101334);
    Language_Compile_Symbol_symbolTop -= 1;
    TLRESTORELF();
}

static void Language_Compile_Symbol_DumpExports (ex, file, indent)
struct Language_Compile_ExportDef	*ex;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_ExportDef	*e;
    TLSTKCHKSLF(101340);
    TLSETF();
    TLSETL(101340);
    e = ex;
    TLSETL(101343);
    Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "export (", (TLint2) file);
    TLINCL();
    if (e != ((struct Language_Compile_ExportDef *) 0)) {
	TLSETL(101346);
	for(;;) {
	    TLSETL(101346);
	    if ((TLSMLSMLSETCONST(0) & (e->kind)) != 0) {
		TLSETL(101347);
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "opaque ", (TLint2) file);
	    };
	    TLSETL(101349);
	    if ((TLSMLSMLSETCONST(1) & (e->kind)) != 0) {
		TLSETL(101350);
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "pervasive ", (TLint2) file);
	    };
	    TLSETL(101352);
	    if ((TLSMLSMLSETCONST(2) & (e->kind)) != 0) {
		TLSETL(101353);
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "unqualified ", (TLint2) file);
	    };
	    TLSETL(101355);
	    if ((TLSMLSMLSETCONST(3) & (e->kind)) != 0) {
		TLSETL(101356);
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "var ", (TLint2) file);
	    };
	    TLSETL(101358);
	    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, (e->identPtr->str), (TLint2) file);
	    TLINCL();
	    e = e->next;
	    TLINCL();
	    if (e == ((struct Language_Compile_ExportDef *) 0)) {
		break;
	    };
	    TLSETL(101361);
	    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, ", ", (TLint2) file);
	};
    };
    TLSETL(101364);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLRESTORELF();
}

static void Language_Compile_Symbol_DumpImports (im, file, indent)
struct Language_Compile_ImportDef	*im;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_ImportDef	*i;
    TLSTKCHKSLF(101369);
    TLSETF();
    TLSETL(101369);
    i = im;
    TLSETL(101372);
    Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "import (", (TLint2) file);
    TLINCL();
    if (i != ((struct Language_Compile_ImportDef *) 0)) {
	TLSETL(101375);
	for(;;) {
	    TLSETL(101375);
	    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, (i->sy->identPtr->str), (TLint2) file);
	    TL_TLI_TLIPS ((TLint4) 0, " (", (TLint2) file);
	    TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_AccessName[TLINRANGELOW(i->newAccess, 0, 2, 1)]), (TLint2) file);
	    TL_TLI_TLIPN ((TLint4) 4, (TLnat4) (i->oldImportDepth), (TLint2) file);
	    TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
	    TLSETL(101378);
	    i = i->next;
	    TLINCL();
	    if (i == ((struct Language_Compile_ImportDef *) 0)) {
		break;
	    };
	    TLSETL(101380);
	    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, ", ", (TLint2) file);
	};
    };
    TLSETL(101383);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLRESTORELF();
}

static void Language_Compile_Symbol_OutputSymbolAttributes (attr, file)
Language_Compile_SyAttributeSet	attr;
TLint4	file;
{
    TLSTKCHKSLF(101388);
    TLSETF();
    TLSETL(101388);
    if (attr != 0) {
	TLboolean	first;
	TLSETL(101389);
	first = 1;
	TLINCL();
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "<", (TLint2) file);
	TLINCL();
	{
	    register TLint4	i;
	    for (i = 0; i <= 19; i++) {
		TLSETL(101392);
		if ((TLSMLSETCONST(TLINRANGELOW(i, 0, 19, 19)) & attr) != 0) {
		    TLSETL(101393);
		    if (first) {
			TLSETL(101394);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_SyAttribName[TLINRANGELOW(i, 0, 19, 1)]), (TLint2) file);
			TLINCL();
			first = 0;
		    } else {
			TLSETL(101397);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
			TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_SyAttribName[TLINRANGELOW(i, 0, 19, 1)]), (TLint2) file);
		    };
		};
	    };
	};
	TLSETL(101401);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "> ", (TLint2) file);
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_DumpSymbol (sy, file, indent)
struct Language_Compile_SymbolDef	*sy;
TLint4	file;
TLnat4	indent;
{
    TLSTKCHKSLF(101408);
    TLSETF();
    TLSETL(101408);
    Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(101409);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "(nil symbol)", (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
	TLSETL(101411);
	TLRESTORELF();
	return;
    };
    TLSETL(101412);
    if ((sy->identPtr) == ((struct Language_Compile_IdentDef *) 0)) {
	TLSETL(101413);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "(dummy symbol)", (TLint2) file);
    } else {
	TLSETL(101415);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, (sy->identPtr->str), (TLint2) file);
    };
    TLSETL(101417);
    {
	TLstring	__x2590;
	FileManager_FileName((FileManager_FileNoType) Language_UnitManager_FileNo(sy->loc.unitPtr), __x2590);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, " ", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_SymbolKindName[TLINRANGELOW(sy->u.syTag, 0, 9, 1)]), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, " ", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_AccessName[TLINRANGELOW(sy->access, 0, 2, 1)]), (TLint2) file);
	TL_TLI_TLIPN ((TLint4) 4, (TLnat4) (sy->importDepth), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, " \'", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_PredefData[TLINRANGELOW(sy->predefined, 0, 24, 1)].Name), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, "\' ", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, " (", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_BaseName[TLINRANGELOW(sy->loc.base, 0, 9, 1)]), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_IndirName[TLINRANGELOW(sy->loc.indir, 0, 2, 1)]), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
	TL_TLI_TLIPN ((TLint4) 0, (TLnat4) (sy->loc.offset), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, ",\"", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, __x2590, (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, "\")", (TLint2) file);
    };
    TLSETL(101428);
    Language_Compile_Symbol_OutputSymbolAttributes((Language_Compile_SyAttributeSet) (sy->attributes), (TLint4) file);
    {
	TLstring	__x2591;
	TL_TLS_TLSVNS((TLnat4) (* (TLnat4 *) &sy->blockScope), (TLint4) 1, (TLint4) 16, __x2591);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, " block ", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, __x2591, (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
    };
    TLINCL();
    if (((sy->definingSy) != ((struct Language_Compile_SymbolDef *) 0)) && ((sy->definingSy->identPtr) != ((struct Language_Compile_IdentDef *) 0))) {
	TLSETL(101432);
	Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "defined by ", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (sy->definingSy->identPtr->str), (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
    };
    TLSETL(101435);
    switch (sy->u.syTag) {
	case 1:
	case 5:
	    {
		TLSETL(101437);
		if ((sy->u.__u1.__u2.mExpandSy) != ((struct Language_Compile_SymbolDef *) 0)) {
		    TLSETL(101439);
		    Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		    if ((sy->u.__u1.__u2.mExpandSy->identPtr) == ((struct Language_Compile_IdentDef *) 0)) {
			TLSETL(101440);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, "expand anyclass", (TLint2) file);
			TL_TLI_TLIPK ((TLint2) file);
		    } else {
			TLSETL(101442);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, "expand ", (TLint2) file);
			TL_TLI_TLIPS ((TLint4) 0, (sy->u.__u1.__u2.mExpandSy->identPtr->str), (TLint2) file);
			TL_TLI_TLIPK ((TLint2) file);
		    };
		};
		TLSETL(101447);
		Language_Compile_Types_DumpType(sy->tyPtr, (TLint4) file, (TLnat4) (indent + 4));
		TLINCL();
		Language_Compile_Symbol_DumpSymbol(sy->u.__u1.__u2.mClassTagSy, (TLint4) file, (TLnat4) (indent + 4));
		TLINCL();
		Language_Compile_Symbol_DumpImports(sy->u.__u1.__u2.mImportsOf, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101451);
		Language_Compile_Symbol_DumpExports(sy->u.__u1.__u2.mExportsOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 2:
	    break;
	case 3:
	    {
		TLSETL(101455);
		Language_Compile_Types_DumpType(sy->tyPtr, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101457);
		Language_Compile_Value_DumpValue(sy->u.__u1.__u3.cValue, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 4:
	    {
		TLSETL(101459);
		Language_Compile_Symbol_DumpSymbolList(sy->u.__u1.__u4.fFormalsOf, (TLint4) file, (TLnat4) (indent + 4));
		TLINCL();
		Language_Compile_Symbol_DumpSymbol(sy->u.__u1.__u4.ResultsId, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101462);
		Language_Compile_Types_DumpType(sy->u.__u1.__u4.ResultType, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 6:
	    {
		TLSETL(101464);
		Language_Compile_Symbol_DumpSymbolList(sy->u.__u1.__u5.pFormalsOf, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101466);
		Language_Compile_Value_DumpValue(sy->u.__u1.__u5.pValue, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 9:
	    {
		TLSETL(101468);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "union body #", (TLint2) file);
		TL_TLI_TLIPI ((TLint4) 0, (TLint4) (sy->u.__u1.__u6.unionNumber), (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
	    }
	    break;
	default :
	    {
		TLSETL(101472);
		Language_Compile_Types_DumpType(sy->tyPtr, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_DumpSymbolList (sy, file, indent)
struct Language_Compile_SymbolDef	*sy;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_SymbolDef	*s;
    TLSTKCHKSLF(101477);
    TLSETF();
    TLSETL(101477);
    s = sy;
    TLSETL(101479);
    for(;;) {
	TLSETL(101479);
	if (((s == ((struct Language_Compile_SymbolDef *) 0)) || ((s->predefined) != 0)) || Language_UnitManager_IsPredef(s->loc.unitPtr)) {
	    break;
	};
	TLSETL(101483);
	Language_Compile_Symbol_DumpSymbol(s, (TLint4) file, (TLnat4) indent);
	s = s->next;
    };
    TLRESTORELF();
}

void Language_Compile_Symbol_DumpSymbolStack (file)
TLint4	file;
{
    TLSTKCHKSLF(101489);
    TLSETF();
    TLSETL(101489);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "Symbol Stack Dump:", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLINCL();
    {
	register TLint4	s;
	for (s = Language_Compile_Symbol_symbolTop; s >= 1; s--) {
	    TLSETL(101492);
	    Language_Compile_Symbol_DumpSymbol(Language_Compile_Symbol_symbolStack[TLINRANGELOW(s, 1, 30, 1)], (TLint4) file, (TLnat4) 0);
	};
    };
    TLSETL(101493);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLRESTORELF();
}

void Language_Compile_Symbol_AssertStackEmpty () {
    TLSTKCHKSLF(101498);
    TLSETF();
    TLSETL(101498);
    TLASSERT (Language_Compile_Symbol_symbolTop == 0);
    TLRESTORELF();
}

void Language_Compile_Symbol_Initialize () {
    TLSTKCHKSLF(101504);
    TLSETF();
    TLSETL(101504);
    Language_Compile_Symbol_symbolTop = 0;
    TLINCL();
    Language_Compile_Symbol_freeSymbolChain = (struct Language_Compile_SymbolDef *) 0;
    TLRESTORELF();
}

void Language_Compile_Symbol () {
    TLSAVELF();
    TLSETF();
    TLSETL(100038);
    Language_Compile_Symbol_freeSymbolChain = (struct Language_Compile_SymbolDef *) 0;
    TLRESTORELF();
}
