#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[1523];
} TLFTAB =
    { 26,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 't', 'y', 'p', 'e', 's', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 't', 'y', 'p', 'e', 's', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', '.', '.', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 'b', 'd', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'g', 'l', 'o', 'b', 'a', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 'd', 'f', '2', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'e', 'r', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'm', 'e', 'm', 'o', 'r', 'y', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '/', 's', 'c', 'a', 'n', 'n', 'e', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'p', 'r', 'e', 's', 'c', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 's', 'c', 'o', 'p', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'v', 'a', 'l', 'u', 'e', '.', 's', 't', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x2376[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x2376	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

extern void Language_Debugging ();

extern void Language_Paragraph ();

extern void Language_Reset ();

extern void Language_SetMaxErrorCount ();
typedef	TLstring	__x2377[20];

extern void Language_EnterPreprocSymbols ();

extern void Language_CompileUnit ();

extern void Language_CompileProgram ();

extern void Language_WriteObjectFile ();
typedef	TLstring	__x2380[21];
typedef	TLstring	__x2384[21];

extern void Language_SetupExecution ();
typedef	TLint1	Language_Step;

extern void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();

extern void Language_DumpThreadList ();

extern void Language_DumpUnitList ();

extern void Language_DumpScopeInfo ();

extern void Language_DumpSymbolInfo ();

extern void Language_DumpArrayBounds ();

extern void Language_DumpArrayValues ();
extern TLboolean	Language_debug;
extern struct SrcPosition	Language_nullSrcPosition;
extern struct Cookie	Language_nullCookie;
extern struct DumpSymbolDef	Language_nullSymbolDef;
extern struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x2388[22];
typedef	Language___x2388	Language___x2387[255];
extern Language___x2387	Language_OpcodeName;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x2390 {
    TLint4	lower, range;
};
typedef	struct Language___x2390	Language___x2389[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x2389	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x2391[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x2391	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x2392[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x2392	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x2395[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();

extern TLaddressint malloc ();

extern TLaddressint realloc ();

extern void free ();
typedef	TLnat1	Language_Compile_Tok;
typedef	TLchar	Language_Compile___x2400[16];
struct	Language_Compile___x2399 {
    Language_Compile___x2400	Name;
    TLnat2	Precedence;
};
typedef	struct Language_Compile___x2399	Language_Compile___x2398[159];
extern Language_Compile___x2398	Language_Compile_TokData;
typedef	TLint1	Language_Compile_PPTok;
typedef	TLchar	Language_Compile___x2402[8];
typedef	Language_Compile___x2402	Language_Compile___x2401[16];
extern Language_Compile___x2401	Language_Compile_PPTokName;
typedef	TLint1	Language_Compile_TypeKind;
typedef	TLchar	Language_Compile___x2404[16];
typedef	Language_Compile___x2404	Language_Compile___x2403[33];
extern Language_Compile___x2403	Language_Compile_TypeKindName;
typedef	TLchar	Language_Compile___x2406[16];
typedef	Language_Compile___x2406	Language_Compile___x2405[33];
extern Language_Compile___x2405	Language_Compile_TypeKindKeyword;
typedef	TLint1	Language_Compile_TyModes;
typedef	TLchar	Language_Compile___x2408[12];
typedef	Language_Compile___x2408	Language_Compile___x2407[10];
extern Language_Compile___x2407	Language_Compile_TyModeName;
typedef	TLnat2	Language_Compile_TyModesSet;
typedef	TLint2	Language_Compile_PredType;
typedef	Language_Compile_TypeKind	Language_Compile___x2409[27];
extern Language_Compile___x2409	Language_Compile_PredTypeKind;
typedef	Language_Compile_TyModesSet	Language_Compile___x2410[27];
extern Language_Compile___x2410	Language_Compile_PredTypeMode;
typedef	TLint2	Language_Compile_FormalType;
typedef	TLint2	Language_Compile_Predef;
typedef	TLchar	Language_Compile___x2413[20];
struct	Language_Compile___x2412 {
    Language_Compile___x2413	Name;
    Language_Compile_FormalType	FormalList;
    Language_Compile_PredType	ResultType;
};
typedef	struct Language_Compile___x2412	Language_Compile___x2411[25];
extern Language_Compile___x2411	Language_Compile_PredefData;
typedef	TLchar	Language_Compile___x2414[256];
struct	Language_Compile_CharDef {
    TLint4	len;
    Language_Compile___x2414	val;
};
struct	Language_Compile_IdentDef {
    struct Language_Compile_IdentDef	*nextIdent;
    Language_Compile_Tok	tok;
    Language_Compile_PPTok	ppTok;
    Language_StringDef	str;
};
typedef	TLint1	Language_Compile_SymbolKind;
typedef	TLchar	Language_Compile___x2416[14];
typedef	Language_Compile___x2416	Language_Compile___x2415[10];
extern Language_Compile___x2415	Language_Compile_SymbolKindName;
typedef	TLint1	Language_Compile_Access;
typedef	TLchar	Language_Compile___x2418[6];
typedef	Language_Compile___x2418	Language_Compile___x2417[3];
extern Language_Compile___x2417	Language_Compile_AccessName;
typedef	TLint1	Language_Compile_SyAttributes;
typedef	TLchar	Language_Compile___x2420[16];
typedef	Language_Compile___x2420	Language_Compile___x2419[20];
extern Language_Compile___x2419	Language_Compile_SyAttribName;
typedef	TLnat4	Language_Compile_SyAttributeSet;
typedef	TLnat1	Language_Compile_ImportDepthType;
struct	Language_Compile_IndexDef {
    struct Language_Compile_IndexDef	*next;
    struct Language_Compile_TypeDef	*ty;
};
typedef	TLint1	Language_Compile_ExportKind;
typedef	TLchar	Language_Compile___x2422[16];
typedef	Language_Compile___x2422	Language_Compile___x2421[4];
extern Language_Compile___x2421	Language_Compile_ExportKindName;
typedef	TLnat1	Language_Compile_ExportKindSet;
struct	Language_Compile_ExportDef {
    struct Language_Compile_ExportDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_SymbolDef	*symbolPtr;
    struct Language_Compile_TypeDef	*opaqueTypePtr;
    Language_Compile_ExportKindSet	kind;
};
struct	Language_Compile_ImportDef {
    struct Language_Compile_ImportDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    Language_Compile_Access	newAccess;
    Language_Compile_Access	oldAccess;
    Language_Compile_ImportDepthType	oldImportDepth;
    TLboolean	overridesExpand;
};
struct	Language_Compile_DynamicDef {
    struct Language_Compile_DynamicDef	*next;
    struct Language_Compile_SymbolDef	*sy;
};
typedef	TLint1	Language_Compile_BlockKind;
typedef	TLchar	Language_Compile___x2424[10];
typedef	Language_Compile___x2424	Language_Compile___x2423[16];
extern Language_Compile___x2423	Language_Compile_BlockKindName;
struct	Language_Compile_BlockDef {
    struct Language_Compile_BlockDef	*parentBlock;
    struct Language_Compile_BlockDef	*siblingBlock;
    struct Language_Compile_BlockDef	*childBlock;
    struct Language_Compile_BlockDef	*expandBlock;
    struct Language_Compile_SymbolDef	*internalSymbols;
    struct Language_Compile_SymbolDef	*parentSymbols;
    struct Language_Compile_SymbolDef	*definingSymbol;
    Language_Offset	codeStartOffset;
    Language_Offset	codeEndOffset;
    struct Language_Compile_DynamicDef	*dynamics;
    Language_Compile_BlockKind	kind;
    TLboolean	reachable;
    TLboolean	resolvingNeeded;
};
typedef	TLint1	Language_Compile_Base;
typedef	TLchar	Language_Compile___x2426[12];
typedef	Language_Compile___x2426	Language_Compile___x2425[10];
extern Language_Compile___x2425	Language_Compile_BaseName;
typedef	TLint1	Language_Compile_Indirection;
typedef	TLchar	Language_Compile___x2428[10];
typedef	Language_Compile___x2428	Language_Compile___x2427[3];
extern Language_Compile___x2427	Language_Compile_IndirName;
struct	Language_Compile_Location {
    void	*unitPtr;
    Language_Compile_Base	base;
    Language_Compile_Indirection	indir;
    Language_Offset	offset;
};
extern struct Language_Compile_Location	Language_Compile_nullLocation;
struct	Language_Compile_DeferredLocDef {
    struct Language_Compile_DeferredLocDef	*next;
    struct Language_Compile_SymbolDef	*sy;
    struct Language_Compile_Location	loc;
};
struct	Language_Compile___x2429 {
    Language_Compile_SymbolKind	syTag;
    union {
	struct {
	    struct Language_Compile_SymbolDef	*mExpandSy;
	    struct Language_Compile_ImportDef	*mImportsOf;
	    struct Language_Compile_ExportDef	*mExportsOf;
	    Language_Compile_ExportKindSet	mExportAllKind;
	    struct Language_Compile_SymbolDef	*mMonitorVar;
	    struct Language_Compile_SymbolDef	*mClassTagSy;
	    TLint4	mDeferredNum;
	    struct Language_Compile_DeferredLocDef	*mDeferredLocs;
	} __u2;
	struct {
	    struct Language_Compile_ValueDef	*cValue;
	} __u3;
	struct {
	    struct Language_Compile_SymbolDef	*fFormalsOf;
	    struct Language_Compile_ImportDef	*fImportsOf;
	    struct Language_Compile_SymbolDef	*ResultsId;
	    struct Language_Compile_TypeDef	*ResultType;
	} __u4;
	struct {
	    struct Language_Compile_SymbolDef	*pFormalsOf;
	    struct Language_Compile_ImportDef	*pImportsOf;
	    struct Language_Compile_ValueDef	*pValue;
	} __u5;
	struct {
	    TLint4	unionNumber;
	} __u6;
    } __u1;
} ;
struct	Language_Compile_SymbolDef {
    struct Language_Compile_SymbolDef	*next;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile_TypeDef	*tyPtr;
    Language_Compile_Access	access;
    Language_Compile_ImportDepthType	importDepth;
    Language_Compile_Predef	predefined;
    Language_Compile_SyAttributeSet	attributes;
    struct Language_Compile_SymbolDef	*definingSy;
    struct Language_Compile_BlockDef	*blockScope;
    struct Language_Compile_Location	loc;
    struct SrcPosition	srcPos;
    Language_Offset	definingOffset;
    struct Language_Compile___x2429	u;
};
struct	Language_Compile_IntListDef {
    struct Language_Compile_IntListDef	*next;
    TLint4	value;
};
struct	Language_Compile_UnionDef {
    struct Language_Compile_UnionDef	*next;
    struct Language_Compile_SymbolDef	*firstSym;
    TLint4	numSyms;
    struct Language_Compile_IntListDef	*values;
    TLint4	uloc;
};
struct	Language_Compile___x2430 {
    Language_Compile_TypeKind	tyTag;
    union {
	struct {
	    struct Language_Compile_IndexDef	*IndexOf;
	    struct Language_Compile_TypeDef	*aElementOf;
	    struct Language_Compile_Location	aDescriptor;
	} __u8;
	struct {
	    struct Language_Compile_SymbolDef	*cNameOf;
	    struct Language_Compile_TypeDef	*cPointerTy;
	    struct Language_Compile_TypeDef	*cUPointerTy;
	} __u9;
	struct {
	    struct Language_Compile_SymbolDef	*EnumIds;
	    struct Language_Compile_Location	eDescriptor;
	} __u10;
	struct {
	    struct Language_Compile_BlockDef	*blockLevel;
	} __u11;
	struct {
	    struct Language_Compile_SymbolDef	*sNameOf;
	} __u12;
	struct {
	    struct Language_Compile_SymbolDef	*oNameOf;
	    struct Language_Compile_TypeDef	*tyOf;
	} __u13;
	struct {
	    struct Language_Compile_SymbolDef	*pNameOf;
	    struct Language_Compile_TypeDef	*pElementOf;
	} __u14;
	struct {
	    struct Language_Compile_SymbolDef	*rFieldsOf;
	} __u15;
	struct {
	    struct Language_Compile_TypeDef	*BaseOf;
	    TLboolean	sIsScalar;
	} __u16;
	struct {
	    TLint4	stringSize;
	} __u17;
	struct {
	    struct Language_Compile_Location	sDescriptor;
	} __u18;
	struct {
	    TLint4	low;
	    TLint4	high;
	    struct Language_Compile_TypeDef	*Root;
	} __u19;
	struct {
	    struct Language_Compile_SymbolDef	*TagOf;
	    struct Language_Compile_SymbolDef	*uFieldsOf;
	    struct Language_Compile_UnionDef	*map;
	    struct Language_Compile_Location	mapLocation;
	    struct Language_Compile_Location	uninitMap;
	} __u20;
	struct {
	    struct Language_Compile_TypeDef	*tyPtr;
	} __u21;
    } __u7;
} ;
struct	Language_Compile_TypeDef {
    struct Language_Compile_SymbolDef	*typeName;
    Language_Compile_TyModesSet	mode;
    TLint1	alignment;
    struct Language_Compile_Location	uninitTableLoc;
    TLint4	tSize;
    struct Language_Compile___x2430	u;
};
typedef	TLint1	Language_Compile_ValueKind;
typedef	TLchar	Language_Compile___x2432[16];
typedef	Language_Compile___x2432	Language_Compile___x2431[9];
extern Language_Compile___x2431	Language_Compile_ValueKindName;
typedef	TLnat4	Language_Compile_ValueSetType;
struct	Language_Compile___x2433 {
    Language_Compile_ValueKind	valTag;
    union {
	struct {
	    struct Language_Compile_ValueDef	*next;
	} __u23;
	struct {
	    TLboolean	boolVal;
	} __u24;
	struct {
	    TLchar	charVal;
	} __u25;
	struct {
	    struct Language_Compile_CharDef	*cstrVal;
	} __u26;
	struct {
	    TLboolean	negative;
	    TLnat4	natVal;
	} __u27;
	struct {
	    TLreal8	realVal;
	} __u28;
	struct {
	    Language_Compile_ValueSetType	setVal;
	} __u29;
	struct {
	    Language_StringDef	*stringVal;
	} __u30;
    } __u22;
} ;
struct	Language_Compile_ValueDef {
    TLboolean	saved;
    struct Language_Compile___x2433	u;
};
struct	Language_Compile___x2434 {
    Language_Compile_Tok	tok;
    union {
	struct {
	    struct Language_Compile_CharDef	*cstrPtr;
	} __u32;
	struct {
	    TLnat4	natVal;
	} __u33;
	struct {
	    TLreal8	realVal;
	} __u34;
	struct {
	    Language_StringDef	*strPtr;
	} __u35;
    } __u31;
} ;
struct	Language_Compile_TokRecord {
    struct SrcPosition	srcPos;
    struct Language_Compile_IdentDef	*identPtr;
    struct Language_Compile___x2434	u;
};
extern struct Language_Compile_TokRecord	Language_Compile_newTok;
extern struct Language_Compile_TokRecord	Language_Compile_oldTok;

extern char *strcpy ();

void Language_Compile_CleanChar ();

void Language_Compile_CleanCString ();

void Language_Compile_IdentToName ();

void Language_Compile_TokenToName ();

void Language_Compile_SymbolToName ();
extern void	*Language_Compile_compilingUnit;
extern void	*Language_Compile_predefUnit;

extern void Language_Compile_CompileError_Add ();

extern void Language_Compile_CompileError_Initialize ();

extern TLnat4 Language_Compile_CompileError_Count ();

extern void Language_Compile_Memory_Initialize ();

extern void Language_Compile_Memory_Allocate ();

extern void Language_Compile_Memory_Trim ();
typedef	struct Language_Compile_IdentDef	*Language_Compile___x2455[118];
extern Language_Compile___x2455	Language_Compile_keywordIdent;
struct	Language_Compile___x2456 {
    struct Language_Compile_IdentDef	*anyclass;
    struct Language_Compile_IdentDef	*main;
    struct Language_Compile_IdentDef	*unit;
};
extern struct Language_Compile___x2456	Language_Compile_specialIdent;

extern void Language_Compile_Scanner_Reset ();

extern void Language_Compile_Scanner_EnterTok ();

extern void Language_Compile_Scanner_Initialize ();

extern void Language_Compile_Scanner_Scan ();

extern void Language_Compile_Scanner_GetFileUnit ();
typedef	TLstring	__x2457[20];

extern void Language_Compile_Scanner_EnterPreprocSymbols ();

void Language_Compile_DemandToken ();

void Language_Compile_ExpectToken ();

void Language_Compile_ExpectEnd ();

void Language_Compile_EqWantColonEq ();

void Language_Compile_GetUnitFile ();

void Language_Compile_InitializeScan ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_PreScan_VerifyConfiguration ();

extern void Language_Compile_PreScan_VerifyPredefList ();
extern struct Language_Compile_BlockDef	*Language_Compile_rootBlock;
extern struct Language_Compile_BlockDef	*Language_Compile_blockStack;
extern struct Language_Compile_SymbolDef	*Language_Compile_compilingSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_monitorSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_classSymbol;
extern struct Language_Compile_SymbolDef	*Language_Compile_subprogramSymbol;
extern Language_Compile_ImportDepthType	Language_Compile_currentImportDepth;
extern struct Language_Compile_ValueDef	*Language_Compile_nonCompileTimeValue;
extern struct Language_Compile_ValueDef	*Language_Compile_intValueOne;
typedef	struct Language_Compile_TypeDef	*Language_Compile___x2466[27];
extern Language_Compile___x2466	Language_Compile_predType;
extern TLint4	Language_Compile_debugFile;
extern void 	(*Language_Compile_DumpAll)();
extern void 	(*Language_Compile_procDumpSym)();
extern void 	(*Language_Compile_procDumpSymList)();
extern void 	(*Language_Compile_procTargetType)();

void Language_Compile_OutputIndent ();

extern TLboolean Language_Compile_Scope_AncestorOf ();

extern TLboolean Language_Compile_Scope_AtTopLevel ();

extern TLboolean Language_Compile_Scope_ExpandScopeOk ();

extern struct Language_Compile_ExportDef * Language_Compile_Scope_IdentInExportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImmediateScope ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInImportList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInList ();

extern struct Language_Compile_SymbolDef * Language_Compile_Scope_IdentInScope ();

extern TLboolean Language_Compile_Scope_InBlock ();

extern void Language_Compile_Scope_DumpBlocks ();

extern struct Language_Compile_CharDef * Language_Compile_Value_CharValue ();

extern void Language_Compile_Value_Chr ();

extern void Language_Compile_Value_ConvertToChar ();

extern void Language_Compile_Value_ConvertToCharString ();

extern void Language_Compile_Value_ConvertToReal ();

extern void Language_Compile_Value_ConvertToString ();

extern void Language_Compile_Value_EnterSetValue ();

extern void Language_Compile_Value_Initialize ();

extern TLint4 Language_Compile_Value_IntValue ();

extern Language_Compile_ValueKind Language_Compile_Value_Kind ();

extern void Language_Compile_Value_NonCompileTimeOperation ();

extern void Language_Compile_Value_Ord ();

extern void Language_Compile_Value_PerformOperation ();

extern void Language_Compile_Value_PerformUnaryOperation ();

extern void Language_Compile_Value_Pop ();

extern void Language_Compile_Value_Push ();

extern void Language_Compile_Value_PushCopy ();

extern void Language_Compile_Value_PushInt ();

extern void Language_Compile_Value_PushSet ();

extern void Language_Compile_Value_PushToken ();

extern TLreal8 Language_Compile_Value_RealValue ();

extern void Language_Compile_Value_ReplaceLowHighWithEmptySet ();

extern void Language_Compile_Value_ReplaceLowHighWithSetAll ();

extern void Language_Compile_Value_ReplaceNonCompileTime ();

extern void Language_Compile_Value_Save ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Second ();

extern Language_StringDef * Language_Compile_Value_StringValue ();

extern void Language_Compile_Value_Swap ();

extern struct Language_Compile_ValueDef * Language_Compile_Value_Top ();

extern Language_Compile_ValueKind Language_Compile_Value_ValKind ();

extern struct Language_Compile_TypeDef * Language_Compile_Value_ValueType ();

extern void Language_Compile_Value_AssertStackEmpty ();

extern void Language_Compile_Value_DumpValue ();

extern void Language_Compile_Value_DumpValueStack ();

TLint4 Language_Compile_Types_Alignment ();

TLboolean Language_Compile_Types_Assignable ();

void Language_Compile_Types_ClearMode ();

void Language_Compile_Types_EnterAlignment ();

void Language_Compile_Types_EnterDescriptorLocation ();

void Language_Compile_Types_EnterElementType ();

void Language_Compile_Types_EnterIndices ();

void Language_Compile_Types_EnterMode ();

void Language_Compile_Types_EnterPointerType ();

void Language_Compile_Types_EnterPointerUncheckedType ();

void Language_Compile_Types_EnterSetBase ();

void Language_Compile_Types_EnterSize ();

void Language_Compile_Types_EnterStorageSize ();

void Language_Compile_Types_EnterTypeName ();

void Language_Compile_Types_EnterUnionInfo ();

void Language_Compile_Types_EnterUnionTag ();

struct Language_Compile_SymbolDef * Language_Compile_Types_EnumIds ();

TLboolean Language_Compile_Types_EquivVarType ();

struct Language_Compile_SymbolDef * Language_Compile_Types_FieldsOf ();

TLboolean Language_Compile_Types_HasMode ();

TLint4 Language_Compile_Types_High ();

struct Language_Compile_IndexDef * Language_Compile_Types_IndexOf ();

void Language_Compile_Types_Initialize ();

TLboolean Language_Compile_Types_IsCondition ();

TLboolean Language_Compile_Types_IsDynamicType ();

TLboolean Language_Compile_Types_IsIntType ();

TLboolean Language_Compile_Types_IsNumeric ();

TLboolean Language_Compile_Types_IsScalar ();

Language_Compile_TypeKind Language_Compile_Types_Kind ();

void Language_Compile_Types_LinkIdentListToType ();

TLint4 Language_Compile_Types_Low ();

void Language_Compile_Types_MakeTypeOpaque ();

struct Language_Compile_SymbolDef * Language_Compile_Types_NameOf ();

Language_Compile_TypeKind Language_Compile_Types_NumericKind ();

void Language_Compile_Types_NumericType ();

void Language_Compile_Types_Pack ();

void Language_Compile_Types_Pop ();

void Language_Compile_Types_PushBaseOf ();

void Language_Compile_Types_PushElementType ();

void Language_Compile_Types_PushNew ();

void Language_Compile_Types_PushTagType ();

void Language_Compile_Types_PushType ();

void Language_Compile_Types_ReplaceCopy ();

void Language_Compile_Types_ReplaceElementType ();

void Language_Compile_Types_ReplacePointerType ();

void Language_Compile_Types_ReplaceRootType ();

void Language_Compile_Types_ReplaceSecondRootType ();

void Language_Compile_Types_ReplaceType ();

void Language_Compile_Types_ResetPredefines ();

void Language_Compile_Types_ResolveForward ();

struct Language_Compile_TypeDef * Language_Compile_Types_RootType ();

Language_Compile_TypeKind Language_Compile_Types_RootTypeKind ();

TLboolean Language_Compile_Types_Same ();

TLboolean Language_Compile_Types_SameType ();

struct Language_Compile_TypeDef * Language_Compile_Types_Second ();

Language_Compile_TypeKind Language_Compile_Types_SecondKind ();

TLint4 Language_Compile_Types_StrSize ();

TLboolean Language_Compile_Types_StringComparisonTypes ();

TLboolean Language_Compile_Types_StringTypes ();

void Language_Compile_Types_Swap ();

struct Language_Compile_SymbolDef * Language_Compile_Types_Tag ();

struct Language_Compile_TypeDef * Language_Compile_Types_Third ();

struct Language_Compile_TypeDef * Language_Compile_Types_Top ();

TLint4 Language_Compile_Types_TypeSize ();

struct Language_Compile_UnionDef * Language_Compile_Types_UnionMap ();

void Language_Compile_Types_UnmakeTypeOpaque ();

struct Language_Compile_TypeDef * Language_Compile_Types_UnOpaqueType ();

TLboolean Language_Compile_Types_UnresolvedCollection ();

void Language_Compile_Types_AssertStackEmpty ();

void Language_Compile_Types_DumpType ();

void Language_Compile_Types_DumpTypeStack ();
static TLint2	Language_Compile_Types_typeTop;
typedef	struct Language_Compile_TypeDef	*Language_Compile_Types___x2469[30];
static Language_Compile_Types___x2469	Language_Compile_Types_typeStack;
typedef	TLint2	Language_Compile_Types___x2470[27];
static Language_Compile_Types___x2470	Language_Compile_Types_pSize = 
    {1, 1, 4, 0, 8, 4, 8, 256, 2, 4,
    1, 12, 12, 12, 12, 1, 2, 4, 4, 4,
    1, 2, 4, 4, 8, 4, 0};
typedef	TLint2	Language_Compile_Types___x2474[27];
static Language_Compile_Types___x2474	Language_Compile_Types_pAlignment = 
    {1, 1, 4, 4, 4, 4, 4, 1, 1, 4,
    1, 4, 4, 4, 4, 1, 2, 4, 4, 4,
    1, 2, 4, 4, 4, 4, 4};

void Language_Compile_Types_ResetPredefines () {
    TLSTKCHKSLF(100079);
    TLSETF();
    TLSETL(100079);
    {
	register TLint4	i;
	for (i = 0; i <= 26; i++) {
	    TLSETL(100080);
	    TLSTRCTASS(Language_Compile_predType[TLINRANGELOW(i, 0, 26, 1)]->uninitTableLoc, Language_Compile_nullLocation, struct Language_Compile_Location);
	};
    };
    TLRESTORELF();
}
static struct Language_Compile_TypeDef	*Language_Compile_Types_freeTypeChain;

void Language_Compile_Types_PushType (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100095);
    TLSETF();
    TLSETL(100095);
    TLPRE (ty != ((struct Language_Compile_TypeDef *) 0));
    TLINCL();
    if (Language_Compile_Types_typeTop == 30) {
	TLSETL(100099);
	Language_Compile_CompileError_Add((TLint2) 10281, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 3);
    };
    TLSETL(100100);
    Language_Compile_Types_typeTop += 1;
    TLINCL();
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)] = ty;
    TLRESTORELF();
}

void Language_Compile_Types_PushNew (kind)
Language_Compile_TypeKind	kind;
{
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(100106);
    TLSETF();
    TLSETL(100106);
    ty = Language_Compile_Types_freeTypeChain;
    TLINCL();
    if (ty == ((struct Language_Compile_TypeDef *) 0)) {
	struct Language_Compile_TypeDef	*nt;
	TLSETL(100110);
	Language_Compile_Memory_Allocate(&(nt), (TLint2) sizeof(struct Language_Compile_TypeDef));
	ty = nt;
    } else {
	TLSETL(100112);
	Language_Compile_Types_freeTypeChain = ty->u.__u7.__u21.tyPtr;
    };
    TLSETL(100115);
    ty->typeName = (struct Language_Compile_SymbolDef *) 0;
    TLINCL();
    ty->mode = 0x0;
    TLINCL();
    TLSTRCTASS(ty->uninitTableLoc, Language_Compile_nullLocation, struct Language_Compile_Location);
    TLINCL();
    ty->u.tyTag = kind;
    TLSETL(100120);
    switch (kind) {
	case 2:
	    {
		TLSETL(100122);
		ty->u.__u7.__u8.IndexOf = (struct Language_Compile_IndexDef *) 0;
		TLINCL();
		ty->u.__u7.__u8.aElementOf = (struct Language_Compile_TypeDef *) 0;
		TLINCL();
		TLSTRCTASS(ty->u.__u7.__u8.aDescriptor, Language_Compile_nullLocation, struct Language_Compile_Location);
		TLINCL();
		ty->tSize = 0;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 5:
	    {
		TLSETL(100129);
		ty->u.__u7.__u17.stringSize = Language_Compile_Value_IntValue(Language_Compile_Value_Top());
		TLINCL();
		ty->tSize = ty->u.__u7.__u17.stringSize;
		TLINCL();
		ty->tSize += (ty->tSize) & 1;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 6:
	    {
		TLSETL(100135);
		TLSTRCTASS(ty->u.__u7.__u18.sDescriptor, Language_Compile_nullLocation, struct Language_Compile_Location);
		TLINCL();
		ty->tSize = 4;
		TLINCL();
		ty->alignment = 4;
		TLINCL();
		ty->mode = 0x40;
	    }
	    break;
	case 7:
	case 8:
	    {
		TLSETL(100141);
		ty->u.__u7.__u9.cNameOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->u.__u7.__u9.cPointerTy = (struct Language_Compile_TypeDef *) 0;
		TLINCL();
		ty->u.__u7.__u9.cUPointerTy = (struct Language_Compile_TypeDef *) 0;
		TLINCL();
		ty->tSize = 0;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 13:
	    {
		TLSETL(100148);
		ty->u.__u7.__u10.EnumIds = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		TLSTRCTASS(ty->u.__u7.__u10.eDescriptor, Language_Compile_nullLocation, struct Language_Compile_Location);
		TLINCL();
		ty->tSize = 4;
		TLINCL();
		ty->alignment = 4;
		TLINCL();
		ty->mode = 0x200;
	    }
	    break;
	case 14:
	    {
		TLSETL(100155);
		ty->tSize = 0;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(100159);
		ty->u.__u7.__u12.sNameOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->tSize = 4;
		TLINCL();
		ty->alignment = 4;
		TLINCL();
		ty->mode = 0x200;
	    }
	    break;
	case 21:
	    {
		TLSETL(100165);
		ty->u.__u7.__u14.pNameOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->u.__u7.__u14.pElementOf = (struct Language_Compile_TypeDef *) 0;
		TLINCL();
		ty->tSize = 8;
		TLINCL();
		ty->alignment = 4;
		TLINCL();
		ty->mode = 0x200;
	    }
	    break;
	case 25:
	    {
		TLSETL(100172);
		ty->u.__u7.__u15.rFieldsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->tSize = 0;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 26:
	    {
		TLSETL(100177);
		ty->u.__u7.__u16.BaseOf = (struct Language_Compile_TypeDef *) 0;
		TLINCL();
		ty->u.__u7.__u16.sIsScalar = 1;
		TLINCL();
		ty->tSize = 4;
		TLINCL();
		ty->alignment = 4;
	    }
	    break;
	case 28:
	    {
		TLSETL(100183);
		ty->u.__u7.__u17.stringSize = Language_Compile_Value_IntValue(Language_Compile_Value_Top());
		TLINCL();
		ty->tSize = (ty->u.__u7.__u17.stringSize) + 1;
		TLSETL(100186);
		ty->alignment = 1;
		TLINCL();
		ty->mode = 0x200;
	    }
	    break;
	case 29:
	    {
		TLSETL(100190);
		TLSTRCTASS(ty->u.__u7.__u18.sDescriptor, Language_Compile_nullLocation, struct Language_Compile_Location);
		TLINCL();
		ty->tSize = 4;
		TLINCL();
		ty->alignment = 4;
		TLINCL();
		ty->mode = 0x240;
	    }
	    break;
	case 30:
	    {
		struct Language_Compile_TypeDef	*rootTy;
		TLSETL(100197);
		ty->u.__u7.__u19.low = Language_Compile_Value_IntValue(Language_Compile_Value_Second());
		TLINCL();
		ty->u.__u7.__u19.high = Language_Compile_Value_IntValue(Language_Compile_Value_Top());
		TLINCL();
		rootTy = Language_Compile_Types_RootType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
		TLINCL();
		if ((rootTy->u.tyTag) == 19) {
		    TLSETL(100201);
		    rootTy = Language_Compile_predType[2];
		};
		TLSETL(100203);
		ty->u.__u7.__u19.Root = rootTy;
		TLINCL();
		ty->tSize = rootTy->tSize;
		TLINCL();
		ty->alignment =  TLRANGECHECK (rootTy->alignment, 0, 4, 5);
		TLINCL();
		ty->mode = (rootTy->mode) & ((TLSMLSMLSETCONST(9)));
		TLSETL(100208);
		if (Language_Compile_Value_Kind() == 1) {
		    TLSETL(100209);
		    ty->mode |= 0x4;
		};
	    }
	    break;
	case 31:
	    {
		TLSETL(100213);
		ty->u.__u7.__u20.TagOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->u.__u7.__u20.uFieldsOf = (struct Language_Compile_SymbolDef *) 0;
		TLINCL();
		ty->u.__u7.__u20.map = (struct Language_Compile_UnionDef *) 0;
		TLINCL();
		TLSTRCTASS(ty->u.__u7.__u20.mapLocation, Language_Compile_nullLocation, struct Language_Compile_Location);
		TLINCL();
		ty->tSize = 0;
		TLINCL();
		ty->alignment = 1;
	    }
	    break;
	case 0:
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100224);
    Language_Compile_Types_PushType(ty);
    TLRESTORELF();
}

void Language_Compile_Types_MakeTypeOpaque (ty, holdTy)
struct Language_Compile_TypeDef	*ty;
struct Language_Compile_TypeDef	*holdTy;
{
    register struct Language_Compile_TypeDef	*newTy;
    TLSTKCHKSLF(100228);
    TLSETF();
    TLSETL(100228);
    newTy = holdTy;
    TLINCL();
    if (newTy == ((struct Language_Compile_TypeDef *) 0)) {
	TLSETL(100230);
	newTy = Language_Compile_Types_freeTypeChain;
	TLINCL();
	if (newTy == ((struct Language_Compile_TypeDef *) 0)) {
	    struct Language_Compile_TypeDef	*nt;
	    TLSETL(100234);
	    Language_Compile_Memory_Allocate(&(nt), (TLint2) sizeof(struct Language_Compile_TypeDef));
	    newTy = nt;
	} else {
	    TLSETL(100236);
	    Language_Compile_Types_freeTypeChain = newTy->u.__u7.__u21.tyPtr;
	};
    };
    TLSETL(100239);
    TLSTRCTASS((*(newTy)), (*(ty)), struct Language_Compile_TypeDef);
    TLINCL();
    ty->u.tyTag = 20;
    TLINCL();
    ty->u.__u7.__u13.tyOf = newTy;
    TLINCL();
    ty->u.__u7.__u13.oNameOf = ty->typeName;
    TLRESTORELF();
}

void Language_Compile_Types_UnmakeTypeOpaque (ty, holdTy)
struct Language_Compile_TypeDef	*ty;
struct Language_Compile_TypeDef	**holdTy;
{
    TLSTKCHKSLF(100247);
    TLSETF();
    TLSETL(100247);
    TLASSERT ((ty->u.tyTag) == 20);
    TLINCL();
    (*holdTy) = ty->u.__u7.__u13.tyOf;
    TLINCL();
    TLSTRCTASS((*(ty)), (*((*holdTy))), struct Language_Compile_TypeDef);
    TLRESTORELF();
}

struct Language_Compile_TypeDef * Language_Compile_Types_UnOpaqueType (ty)
struct Language_Compile_TypeDef	*ty;
{
    register struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(100254);
    TLSETF();
    TLSETL(100254);
    t = ty;
    TLSETL(100256);
    for(;;) {
	TLSETL(100256);
	if ((t->u.tyTag) != 20) {
	    break;
	};
	TLSETL(100257);
	t = t->u.__u7.__u13.tyOf;
    };
    TLSETL(100259);
    TLRESTORELF();
    return (t);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static void Language_Compile_Types_FreeType (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100264);
    TLSETF();
    TLSETL(100264);
    if ((ty != ((struct Language_Compile_TypeDef *) 0)) && ((TLSMLSMLSETCONST(1) & (ty->mode)) != 0)) {
	TLSETL(100265);
	ty->u.tyTag = 0;
	TLINCL();
	ty->u.__u7.__u21.tyPtr = Language_Compile_Types_freeTypeChain;
	TLINCL();
	Language_Compile_Types_freeTypeChain = ty;
    };
    TLRESTORELF();
}

void Language_Compile_Types_Pop () {
    TLSTKCHKSLF(100274);
    TLSETF();
    TLSETL(100274);
    Language_Compile_Types_FreeType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    Language_Compile_Types_typeTop -= 1;
    TLRESTORELF();
}

void Language_Compile_Types_ReplaceType (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100279);
    TLSETF();
    TLSETL(100279);
    if (ty != (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])) {
	TLSETL(100281);
	Language_Compile_Types_FreeType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
	Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)] = ty;
    };
    TLRESTORELF();
}

void Language_Compile_Types_ReplaceCopy () {
    TLSTKCHKSLF(100287);
    TLSETF();
    TLSETL(100287);
    TLPRE (Language_Compile_Types_typeTop > 0);
    TLSETL(100289);
    Language_Compile_Types_PushNew((Language_Compile_TypeKind) 0);
    TLSTRCTASS((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])), (*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])), struct Language_Compile_TypeDef);
    TLSETL(100291);
    Language_Compile_Types_FreeType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    Language_Compile_Types_typeTop -= 1;
    TLRESTORELF();
}

void Language_Compile_Types_EnterTypeName (sy)
struct Language_Compile_SymbolDef	*sy;
{
    TLSTKCHKSLF(100297);
    TLSETF();
    TLSETL(100297);
    TLPRE ((Language_Compile_Types_typeTop > 0) && ((Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.tyTag) == 14));
    TLINCL();
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->typeName = sy;
    TLRESTORELF();
}

void Language_Compile_Types_ResolveForward () {
    TLBIND((*tFwd), struct Language_Compile_TypeDef);
    TLBIND((*tNew), struct Language_Compile_TypeDef);
    struct Language_Compile_SymbolDef	*typeName;
    Language_Compile_TyModesSet	mode;
    TLSTKCHKSLF(100303);
    TLSETF();
    TLSETL(100303);
    TLPRE (Language_Compile_Types_typeTop > 1);
    TLINCL();
    tFwd = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])));
    tNew = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])));
    TLSETL(100306);
    TLASSERT (((*tFwd).u.tyTag) == 14);
    TLINCL();
    typeName = (*tFwd).typeName;
    TLINCL();
    mode = (*tFwd).mode;
    TLINCL();
    TLSTRCTASS((*tFwd), (*tNew), struct Language_Compile_TypeDef);
    TLINCL();
    (*tFwd).typeName = typeName;
    TLINCL();
    (*tFwd).mode |= mode;
    TLRESTORELF();
}

void Language_Compile_Types_PushTagType () {
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(100316);
    TLSETF();
    TLSETL(100316);
    ty = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    if ((ty->u.tyTag) == 31) {
	TLSETL(100319);
	Language_Compile_Types_PushType(ty->u.__u7.__u20.TagOf->tyPtr);
    } else {
	TLSETL(100321);
	Language_Compile_Types_PushType(Language_Compile_predType[26]);
    };
    TLRESTORELF();
}

static TLboolean Language_Compile_Types_UninitializedField (s)
struct Language_Compile_SymbolDef	*s;
{
    register struct Language_Compile_SymbolDef	*sy;
    TLSTKCHKSLF(100326);
    TLSETF();
    TLSETL(100326);
    sy = s;
    TLSETL(100328);
    for(;;) {
	TLSETL(100328);
	if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
	    break;
	};
	TLSETL(100329);
	if ((TLSMLSMLSETCONST(9) & (sy->tyPtr->mode)) != 0) {
	    TLSETL(100330);
	    TLRESTORELF();
	    return (1);
	};
	TLSETL(100332);
	sy = sy->next;
    };
    TLSETL(100334);
    TLRESTORELF();
    return (0);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLboolean Language_Compile_Types_UninitializeType (t)
struct Language_Compile_TypeDef	*t;
{
    TLSTKCHKSLF(100338);
    TLSETF();
    TLSETL(100338);
    if ((TLSMLSMLSETCONST(9) & (t->mode)) != 0) {
	TLSETL(100339);
	TLRESTORELF();
	return (1);
    };
    TLSETL(100341);
    switch (t->u.tyTag) {
	case 2:
	    {
		TLSETL(100343);
		TLRESTORELF();
		return ((TLSMLSMLSETCONST(9) & (t->u.__u7.__u8.aElementOf->mode)) != 0);
	    }
	    break;
	case 25:
	    {
		TLSETL(100345);
		TLRESTORELF();
		return (Language_Compile_Types_UninitializedField(t->u.__u7.__u15.rFieldsOf));
	    }
	    break;
	case 31:
	    {
		TLSETL(100347);
		TLRESTORELF();
		return (((TLSMLSMLSETCONST(9) & (t->u.__u7.__u20.TagOf->tyPtr->mode)) != 0) || Language_Compile_Types_UninitializedField(t->u.__u7.__u20.uFieldsOf));
	    }
	    break;
	default :
	    {
		TLSETL(100351);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Types_EnterUnionTag (tagSy)
struct Language_Compile_SymbolDef	*tagSy;
{
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(100357);
    TLSETF();
    TLSETL(100357);
    ty = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    TLASSERT ((ty->u.tyTag) == 31);
    TLINCL();
    ty->u.__u7.__u20.TagOf = tagSy;
    TLINCL();
    if ((TLSMLSMLSETCONST(9) & (tagSy->tyPtr->mode)) != 0) {
	TLSETL(100361);
	ty->mode |= 0x200;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterUnionInfo (fields, map)
struct Language_Compile_SymbolDef	*fields;
struct Language_Compile_UnionDef	*map;
{
    TLBINDREG((*ty), struct Language_Compile___x2430);
    TLSTKCHKSLF(100367);
    TLSETF();
    TLSETL(100367);
    ty = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u);
    TLINCL();
    TLASSERT (((*ty).tyTag) == 31);
    TLSETL(100370);
    (*ty).__u7.__u20.uFieldsOf = fields;
    TLINCL();
    (*ty).__u7.__u20.map = map;
    TLRESTORELF();
}

void Language_Compile_Types_LinkIdentListToType (sy)
struct Language_Compile_SymbolDef	*sy;
{
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(100376);
    TLSETF();
    TLSETL(100376);
    ty = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLSETL(100378);
    switch (ty->u.tyTag) {
	case 7:
	case 8:
	    {
		TLSETL(100380);
		ty->u.__u7.__u9.cNameOf = sy;
	    }
	    break;
	case 13:
	    {
		TLSETL(100382);
		ty->u.__u7.__u10.EnumIds = sy;
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(100384);
		ty->u.__u7.__u12.sNameOf = sy;
	    }
	    break;
	case 21:
	    {
		TLSETL(100386);
		ty->u.__u7.__u14.pNameOf = sy;
	    }
	    break;
	case 25:
	    {
		TLSETL(100388);
		ty->u.__u7.__u15.rFieldsOf = sy;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100391);
    if (Language_Compile_Types_UninitializeType(ty)) {
	TLSETL(100392);
	ty->mode |= 0x200;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterElementType () {
    TLBINDREG((*tA), struct Language_Compile_TypeDef *);
    TLBINDREG((*tE), struct Language_Compile_TypeDef *);
    TLSTKCHKSLF(100398);
    TLSETF();
    TLSETL(100398);
    tA = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    tE = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLSETL(100400);
    switch ((*tA)->u.tyTag) {
	case 2:
	    {
		TLSETL(100402);
		(*tA)->u.__u7.__u8.aElementOf = (*tE);
		TLINCL();
		(*tA)->alignment =  TLRANGECHECK ((*tE)->alignment, 0, 4, 5);
		TLINCL();
		if ((TLSMLSMLSETCONST(9) & ((*tE)->mode)) != 0) {
		    TLSETL(100405);
		    (*tA)->mode |= 0x200;
		};
	    }
	    break;
	case 21:
	    {
		TLSETL(100408);
		(*tA)->u.__u7.__u14.pElementOf = (*tE);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterPointerType () {
    TLBINDREG((*tC), struct Language_Compile_TypeDef *);
    TLBINDREG((*tP), struct Language_Compile_TypeDef *);
    TLSTKCHKSLF(100414);
    TLSETF();
    TLSETL(100414);
    tC = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    tP = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLSETL(100416);
    switch ((*tC)->u.tyTag) {
	case 7:
	case 8:
	    {
		TLSETL(100418);
		(*tC)->u.__u7.__u9.cPointerTy = (*tP);
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterPointerUncheckedType () {
    TLBINDREG((*tC), struct Language_Compile_TypeDef *);
    TLBINDREG((*tP), struct Language_Compile_TypeDef *);
    TLSTKCHKSLF(100425);
    TLSETF();
    TLSETL(100425);
    tC = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    tP = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLSETL(100427);
    switch ((*tC)->u.tyTag) {
	case 7:
	case 8:
	    {
		TLSETL(100429);
		(*tC)->u.__u7.__u9.cUPointerTy = (*tP);
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterDescriptorLocation (loc)
struct Language_Compile_Location	*loc;
{
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(100436);
    TLSETF();
    TLSETL(100436);
    ty = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLSETL(100438);
    switch (ty->u.tyTag) {
	case 2:
	    {
		TLSETL(100440);
		TLSTRCTASS(ty->u.__u7.__u8.aDescriptor, (*loc), struct Language_Compile_Location);
	    }
	    break;
	case 6:
	case 29:
	    {
		TLSETL(100442);
		TLSTRCTASS(ty->u.__u7.__u18.sDescriptor, (*loc), struct Language_Compile_Location);
	    }
	    break;
	case 13:
	    {
		TLSETL(100444);
		TLSTRCTASS(ty->u.__u7.__u10.eDescriptor, (*loc), struct Language_Compile_Location);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterIndices (iList)
struct Language_Compile_IndexDef	*iList;
{
    TLSTKCHKSLF(100450);
    TLSETF();
    TLSETL(100450);
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.__u7.__u8.IndexOf = iList;
    TLRESTORELF();
}

void Language_Compile_Types_EnterSetBase () {
    TLBINDREG((*setType), struct Language_Compile_TypeDef);
    TLint4	numBits;
    TLSTKCHKSLF(100455);
    TLSETF();
    TLSETL(100455);
    setType = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])));
    TLINCL();
    (*setType).u.__u7.__u16.BaseOf = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    numBits = Language_Compile_Types_High((*setType).u.__u7.__u16.BaseOf) - Language_Compile_Types_Low((*setType).u.__u7.__u16.BaseOf);
    TLSETL(100459);
    if (numBits < 8) {
	TLSETL(100460);
	(*setType).tSize = 1;
	TLINCL();
	(*setType).alignment = 1;
	TLINCL();
	if (numBits < 7) {
	    TLSETL(100463);
	    (*setType).mode |= 0x200;
	};
	TLSETL(100465);
	(*setType).u.__u7.__u16.sIsScalar = 1;
    } else {
	TLSETL(100466);
	if (numBits < 16) {
	    TLSETL(100467);
	    (*setType).tSize = 2;
	    TLINCL();
	    (*setType).alignment = 2;
	    TLINCL();
	    if (numBits < 15) {
		TLSETL(100470);
		(*setType).mode |= 0x200;
	    };
	    TLSETL(100472);
	    (*setType).u.__u7.__u16.sIsScalar = 1;
	} else {
	    TLSETL(100473);
	    if (numBits < 32) {
		TLSETL(100474);
		(*setType).tSize = 4;
		TLINCL();
		(*setType).alignment = 4;
		TLINCL();
		if (numBits < 31) {
		    TLSETL(100477);
		    (*setType).mode |= 0x200;
		};
		TLSETL(100479);
		(*setType).u.__u7.__u16.sIsScalar = 1;
	    } else {
		TLnat4	numBytes;
		TLSETL(100481);
		numBytes = numBits / 8;
		TLSETL(100483);
		if ((numBytes % 2) != 0) {
		    TLSETL(100484);
		    numBytes += 1;
		} else {
		    TLSETL(100486);
		    numBytes += 2;
		};
		TLSETL(100488);
		(*setType).tSize = numBytes;
		TLINCL();
		if ((numBytes % 4) == 0) {
		    TLSETL(100490);
		    (*setType).alignment = 4;
		} else {
		    TLSETL(100492);
		    (*setType).alignment = 2;
		};
		TLSETL(100494);
		(*setType).u.__u7.__u16.sIsScalar = 0;
	    };
	};
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterSize (sz)
TLint4	sz;
{
    TLBINDREG((*t), struct Language_Compile_TypeDef);
    TLSTKCHKSLF(100500);
    TLSETF();
    TLSETL(100500);
    t = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])));
    TLINCL();
    (*t).tSize = sz;
    TLINCL();
    if ((sz % ((*t).alignment)) != 0) {
	TLSETL(100503);
	(*t).tSize += ((*t).alignment) - (sz % ((*t).alignment));
    };
    TLRESTORELF();
}

void Language_Compile_Types_EnterAlignment (a)
TLint2	a;
{
    TLSTKCHKSLF(100509);
    TLSETF();
    TLSETL(100509);
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->alignment =  TLRANGECHECK (a, 0, 4, 5);
    TLRESTORELF();
}

TLint4 Language_Compile_Types_TypeSize () {
    TLSTKCHKSLF(100514);
    TLSETF();
    TLSETL(100514);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->tSize);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLint4 Language_Compile_Types_Alignment () {
    TLSTKCHKSLF(100519);
    TLSETF();
    TLSETL(100519);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->alignment);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLint4 Language_Compile_Types_StrSize () {
    TLBINDREG((*t), struct Language_Compile_TypeDef);
    TLSTKCHKSLF(100524);
    TLSETF();
    TLSETL(100524);
    t = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])));
    TLSETL(100526);
    switch ((*t).u.tyTag) {
	case 4:
	    {
		TLSETL(100528);
		TLRESTORELF();
		return (1);
	    }
	    break;
	case 5:
	case 28:
	    {
		TLSETL(100530);
		TLRESTORELF();
		return ((*t).u.__u7.__u17.stringSize);
	    }
	    break;
	case 27:
	    {
		TLSETL(100532);
		TLRESTORELF();
		return (255);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_TypeDef * Language_Compile_Types_Top () {
    TLSTKCHKSLF(100538);
    TLSETF();
    TLSETL(100538);
    TLPRE (Language_Compile_Types_typeTop > 0);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_TypeDef * Language_Compile_Types_Second () {
    TLSTKCHKSLF(100544);
    TLSETF();
    TLSETL(100544);
    TLPRE (Language_Compile_Types_typeTop > 1);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_TypeDef * Language_Compile_Types_Third () {
    TLSTKCHKSLF(100550);
    TLSETF();
    TLSETL(100550);
    TLPRE (Language_Compile_Types_typeTop > 2);
    TLINCL();
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 2, 1, 30, 1)]);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLint4 Language_Compile_Types_Low (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100556);
    TLSETF();
    TLSETL(100556);
    switch (ty->u.tyTag) {
	case 16:
	    {
		TLSETL(100558);
		if ((TLSMLSMLSETCONST(9) & (ty->mode)) != 0) {
		    TLSETL(100559);
		    TLRESTORELF();
		    return (-2147483647);
		} else {
		    TLSETL(100561);
		    switch (ty->tSize) {
			case 1:
			    {
				TLSETL(100563);
				TLRESTORELF();
				return (-128);
			    }
			    break;
			case 2:
			    {
				TLSETL(100565);
				TLRESTORELF();
				return (-32768);
			    }
			    break;
			case 4:
			    {
				TLSETL(100567);
				TLRESTORELF();
				return ((TLint4) -0x80000000);
			    }
			    break;
			default :
			    {
				TLSETL(100569);
				TLRESTORELF();
				return (0);
			    }
			    break;
		    };
		};
	    }
	    break;
	case 30:
	    {
		TLSETL(100574);
		TLRESTORELF();
		return (ty->u.__u7.__u19.low);
	    }
	    break;
	default :
	    {
		TLSETL(100577);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLint4 Language_Compile_Types_High (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100583);
    TLSETF();
    TLSETL(100583);
    switch (ty->u.tyTag) {
	case 3:
	    {
		TLSETL(100585);
		TLRESTORELF();
		return (1);
	    }
	    break;
	case 4:
	    {
		TLSETL(100588);
		TLRESTORELF();
		return (255);
	    }
	    break;
	case 13:
	    {
		register struct Language_Compile_SymbolDef	*sy;
		register TLint4	count;
		TLSETL(100591);
		sy = ty->u.__u7.__u10.EnumIds;
		TLINCL();
		count = -1;
		TLSETL(100594);
		for(;;) {
		    TLSETL(100594);
		    if (sy == ((struct Language_Compile_SymbolDef *) 0)) {
			break;
		    };
		    TLSETL(100595);
		    count += 1;
		    TLINCL();
		    sy = sy->next;
		};
		TLSETL(100598);
		TLRESTORELF();
		return (count);
	    }
	    break;
	case 16:
	case 17:
	    {
		TLSETL(100601);
		if ((TLSMLSMLSETCONST(9) & (ty->mode)) != 0) {
		    TLSETL(100602);
		    TLRESTORELF();
		    return (2147483647);
		} else {
		    TLSETL(100604);
		    switch (ty->tSize) {
			case 1:
			    {
				TLSETL(100606);
				TLRESTORELF();
				return (127);
			    }
			    break;
			case 2:
			    {
				TLSETL(100608);
				TLRESTORELF();
				return (32767);
			    }
			    break;
			case 4:
			    {
				TLSETL(100610);
				TLRESTORELF();
				return (2147483647);
			    }
			    break;
			default :
			    {
				TLSETL(100612);
				TLRESTORELF();
				return (0);
			    }
			    break;
		    };
		};
	    }
	    break;
	case 19:
	    {
		TLSETL(100617);
		if ((TLSMLSMLSETCONST(9) & (ty->mode)) != 0) {
		    TLSETL(100618);
		    TLRESTORELF();
		    return (0xFFFFFFFE);
		} else {
		    TLSETL(100620);
		    switch (ty->tSize) {
			case 1:
			    {
				TLSETL(100622);
				TLRESTORELF();
				return (255);
			    }
			    break;
			case 2:
			    {
				TLSETL(100624);
				TLRESTORELF();
				return (65535);
			    }
			    break;
			case 4:
			    {
				TLSETL(100626);
				TLRESTORELF();
				return (0xFFFFFFFF);
			    }
			    break;
			default :
			    {
				TLSETL(100628);
				TLRESTORELF();
				return (0);
			    }
			    break;
		    };
		};
	    }
	    break;
	case 30:
	    {
		TLSETL(100633);
		TLRESTORELF();
		return (ty->u.__u7.__u19.high);
	    }
	    break;
	default :
	    {
		TLSETL(100636);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_TypeKind Language_Compile_Types_Kind () {
    TLSTKCHKSLF(100642);
    TLSETF();
    TLSETL(100642);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.tyTag);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_TypeKind Language_Compile_Types_SecondKind () {
    TLSTKCHKSLF(100647);
    TLSETF();
    TLSETL(100647);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]->u.tyTag);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Types_Swap () {
    struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(100652);
    TLSETF();
    TLSETL(100652);
    t = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)] = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)];
    TLINCL();
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = t;
    TLRESTORELF();
}

static TLboolean Language_Compile_Types_IsString (kind)
Language_Compile_TypeKind	kind;
{
    TLSTKCHKSLF(100659);
    TLSETF();
    TLSETL(100659);
    TLRESTORELF();
    return (((kind == 27) || (kind == 28)) || (kind == 29));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLboolean Language_Compile_Types_IsChar (kind)
Language_Compile_TypeKind	kind;
{
    TLSTKCHKSLF(100665);
    TLSETF();
    TLSETL(100665);
    TLRESTORELF();
    return ((kind == 5) || (kind == 6));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLboolean Language_Compile_Types_SameFormals (formalA, formalB)
struct Language_Compile_SymbolDef	*formalA;
struct Language_Compile_SymbolDef	*formalB;
{
    struct Language_Compile_SymbolDef	*fA;
    struct Language_Compile_SymbolDef	*fB;
    TLSTKCHKSLF(100670);
    TLSETF();
    TLSETL(100670);
    fA = formalA;
    TLINCL();
    fB = formalB;
    TLSETL(100674);
    for(;;) {
	TLBINDREG((*syA), struct Language_Compile_SymbolDef);
	TLBINDREG((*syB), struct Language_Compile_SymbolDef);
	TLSETL(100674);
	if ((fA == ((struct Language_Compile_SymbolDef *) 0)) || (fB == ((struct Language_Compile_SymbolDef *) 0))) {
	    break;
	};
	TLSETL(100675);
	syA = &((*(fA)));
	syB = &((*(fB)));
	TLSETL(100678);
	if (((*syA).u.syTag) != ((*syB).u.syTag)) {
	    TLSETL(100679);
	    TLRESTORELF();
	    return (0);
	};
	TLSETL(100681);
	switch ((*syA).u.syTag) {
	    case 3:
	    case 9:
		{
		    TLSETL(100683);
		    if (!Language_Compile_Types_Same((*syA).tyPtr, (*syB).tyPtr)) {
			TLSETL(100684);
			TLRESTORELF();
			return (0);
		    };
		}
		break;
	    case 6:
		{
		    TLSETL(100688);
		    if (!Language_Compile_Types_SameFormals((*syA).u.__u1.__u5.pFormalsOf, (*syB).u.__u1.__u5.pFormalsOf)) {
			TLSETL(100689);
			TLRESTORELF();
			return (0);
		    };
		}
		break;
	    case 4:
		{
		    TLSETL(100693);
		    if (!Language_Compile_Types_SameFormals((*syA).u.__u1.__u4.fFormalsOf, (*syB).u.__u1.__u4.fFormalsOf)) {
			TLSETL(100694);
			TLRESTORELF();
			return (0);
		    };
		    TLSETL(100696);
		    if (!Language_Compile_Types_Same((*syA).u.__u1.__u4.ResultType, (*syB).u.__u1.__u4.ResultType)) {
			TLSETL(100697);
			TLRESTORELF();
			return (0);
		    };
		}
		break;
	    default:
		TLCASEABORT;
	};
	TLSETL(100701);
	fA = fA->next;
	TLINCL();
	fB = fB->next;
    };
    TLSETL(100704);
    TLRESTORELF();
    return (fA == fB);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_Same (tyA, tyB)
struct Language_Compile_TypeDef	*tyA;
struct Language_Compile_TypeDef	*tyB;
{
    TLBINDREG((*tA), struct Language_Compile_TypeDef);
    TLBINDREG((*tB), struct Language_Compile_TypeDef);
    TLSTKCHKSLF(100709);
    TLSETF();
    TLSETL(100709);
    TLPRE ((tyA != ((struct Language_Compile_TypeDef *) 0)) && (tyB != ((struct Language_Compile_TypeDef *) 0)));
    TLSETL(100711);
    if (tyA == tyB) {
	TLSETL(100712);
	TLRESTORELF();
	return (1);
    };
    TLSETL(100715);
    tA = &((*(tyA)));
    tB = &((*(tyB)));
    TLSETL(100717);
    if (((*tA).u.tyTag) != ((*tB).u.tyTag)) {
	TLSETL(100719);
	TLRESTORELF();
	return ((((*tA).u.tyTag) == 0) || (((*tB).u.tyTag) == 0));
    };
    TLSETL(100722);
    switch ((*tA).u.tyTag) {
	case 2:
	    {
		register struct Language_Compile_IndexDef	*iA;
		register struct Language_Compile_IndexDef	*iB;
		TLSETL(100724);
		if (!Language_Compile_Types_Same((*tA).u.__u7.__u8.aElementOf, (*tB).u.__u7.__u8.aElementOf)) {
		    TLSETL(100725);
		    TLRESTORELF();
		    return (0);
		};
		TLSETL(100728);
		if ((TLSMLSMLSETCONST(3) & (((*tA).mode) ^ ((*tB).mode))) != 0) {
		    TLSETL(100729);
		    TLRESTORELF();
		    return (0);
		};
		TLSETL(100733);
		iA = (*tA).u.__u7.__u8.IndexOf;
		TLINCL();
		iB = (*tB).u.__u7.__u8.IndexOf;
		TLSETL(100736);
		for(;;) {
		    TLSETL(100736);
		    if ((iA == ((struct Language_Compile_IndexDef *) 0)) || (iB == ((struct Language_Compile_IndexDef *) 0))) {
			break;
		    };
		    TLSETL(100737);
		    if (!Language_Compile_Types_Same(iA->ty, iB->ty)) {
			TLSETL(100738);
			TLRESTORELF();
			return (0);
		    };
		    TLSETL(100740);
		    iA = iA->next;
		    TLINCL();
		    iB = iB->next;
		};
		TLSETL(100743);
		TLRESTORELF();
		return (iA == iB);
	    }
	    break;
	case 5:
	case 28:
	    {
		TLSETL(100746);
		TLRESTORELF();
		return (((*tA).u.__u7.__u17.stringSize) == ((*tB).u.__u7.__u17.stringSize));
	    }
	    break;
	case 7:
	case 8:
	    {
		TLSETL(100749);
		TLRESTORELF();
		return (Language_Compile_Types_Same((*tA).u.__u7.__u9.cPointerTy, (*tB).u.__u7.__u9.cPointerTy));
	    }
	    break;
	case 13:
	    {
		TLSETL(100752);
		TLRESTORELF();
		return (((*tA).u.__u7.__u10.EnumIds) == ((*tB).u.__u7.__u10.EnumIds));
	    }
	    break;
	case 14:
	    {
		TLSETL(100755);
		TLRESTORELF();
		return (((*tA).typeName) == ((*tB).typeName));
	    }
	    break;
	case 15:
	    {
		TLSETL(100758);
		TLRESTORELF();
		return (Language_Compile_Types_SameFormals((*tA).u.__u7.__u12.sNameOf->u.__u1.__u4.fFormalsOf, (*tB).u.__u7.__u12.sNameOf->u.__u1.__u4.fFormalsOf) && Language_Compile_Types_Same((*tA).u.__u7.__u12.sNameOf->u.__u1.__u4.ResultType, (*tB).u.__u7.__u12.sNameOf->u.__u1.__u4.ResultType));
	    }
	    break;
	case 16:
	case 19:
	case 24:
	    {
		TLSETL(100764);
		TLRESTORELF();
		return ((((*tA).tSize) == ((*tB).tSize)) && ((TLSMLSMLSETCONST(9) & (((*tA).mode) ^ ((*tB).mode))) == 0));
	    }
	    break;
	case 20:
	    {
		TLSETL(100768);
		TLRESTORELF();
		return (((*tA).u.__u7.__u13.oNameOf) == ((*tB).u.__u7.__u13.oNameOf));
	    }
	    break;
	case 21:
	    {
		TLSETL(100771);
		if ((((*tA).u.__u7.__u14.pElementOf) == ((struct Language_Compile_TypeDef *) 0)) || (((*tB).u.__u7.__u14.pElementOf) == ((struct Language_Compile_TypeDef *) 0))) {
		    TLSETL(100773);
		    TLRESTORELF();
		    return (((*tA).u.__u7.__u14.pElementOf) == ((*tB).u.__u7.__u14.pElementOf));
		} else {
		    TLSETL(100774);
		    if ((TLSMLSMLSETCONST(8) & (((*tA).mode) ^ ((*tB).mode))) != 0) {
			TLSETL(100776);
			TLRESTORELF();
			return (0);
		    } else {
			TLSETL(100777);
			if ((((*tA).u.__u7.__u14.pNameOf) == ((struct Language_Compile_SymbolDef *) 0)) && (((*tB).u.__u7.__u14.pNameOf) == ((struct Language_Compile_SymbolDef *) 0))) {
			    TLSETL(100779);
			    TLRESTORELF();
			    return (Language_Compile_Types_Same((*tA).u.__u7.__u14.pElementOf, (*tB).u.__u7.__u14.pElementOf));
			} else {
			    TLSETL(100782);
			    TLRESTORELF();
			    return (((*tA).u.__u7.__u14.pNameOf) == ((*tB).u.__u7.__u14.pNameOf));
			};
		    };
		};
	    }
	    break;
	case 22:
	case 23:
	    {
		TLSETL(100786);
		TLRESTORELF();
		return (Language_Compile_Types_SameFormals((*tA).u.__u7.__u12.sNameOf->u.__u1.__u5.pFormalsOf, (*tB).u.__u7.__u12.sNameOf->u.__u1.__u5.pFormalsOf));
	    }
	    break;
	case 25:
	    {
		TLSETL(100790);
		TLRESTORELF();
		return (((*tA).u.__u7.__u15.rFieldsOf) == ((*tB).u.__u7.__u15.rFieldsOf));
	    }
	    break;
	case 26:
	    {
		TLSETL(100793);
		TLRESTORELF();
		return (Language_Compile_Types_Same((*tA).u.__u7.__u16.BaseOf, (*tB).u.__u7.__u16.BaseOf));
	    }
	    break;
	case 30:
	    {
		TLSETL(100796);
		if ((Language_Compile_Types_Same((*tA).u.__u7.__u19.Root, (*tB).u.__u7.__u19.Root) && (((*tA).u.__u7.__u19.low) == ((*tB).u.__u7.__u19.low))) && ((TLSMLSMLSETCONST(5) & (((*tA).mode) ^ ((*tB).mode))) == 0)) {
		    TLSETL(100798);
		    if ((TLSMLSMLSETCONST(2) & ((*tA).mode)) != 0) {
			TLSETL(100799);
			TLRESTORELF();
			return ((TLSMLSMLSETCONST(2) & ((*tB).mode)) != 0);
		    } else {
			TLSETL(100800);
			if ((TLSMLSMLSETCONST(2) & ((*tB).mode)) == 0) {
			    TLSETL(100801);
			    TLRESTORELF();
			    return (((*tA).u.__u7.__u19.high) == ((*tB).u.__u7.__u19.high));
			};
		    };
		};
		TLSETL(100804);
		TLRESTORELF();
		return (0);
	    }
	    break;
	case 31:
	    {
		TLSETL(100807);
		TLRESTORELF();
		return ((((*tA).u.__u7.__u20.TagOf) == ((*tB).u.__u7.__u20.TagOf)) && (((*tA).u.__u7.__u20.uFieldsOf) == ((*tB).u.__u7.__u20.uFieldsOf)));
	    }
	    break;
	default :
	    {
		TLSETL(100811);
		TLRESTORELF();
		return (1);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLboolean Language_Compile_Types_EquivVar (tyA, tyB)
struct Language_Compile_TypeDef	*tyA;
struct Language_Compile_TypeDef	*tyB;
{
    TLBINDREG((*tA), struct Language_Compile_TypeDef);
    TLBIND((*tB), struct Language_Compile_TypeDef);
    TLSTKCHKSLF(100817);
    TLSETF();
    TLSETL(100817);
    if (Language_Compile_Types_Same(tyA, tyB)) {
	TLSETL(100818);
	TLRESTORELF();
	return (1);
    };
    TLSETL(100821);
    tA = &((*(tyA)));
    tB = &((*(tyB)));
    TLSETL(100823);
    if (((((*tA).u.tyTag) == 29) && Language_Compile_Types_IsString((Language_Compile_TypeKind) ((*tB).u.tyTag))) || ((((*tB).u.tyTag) == 29) && Language_Compile_Types_IsString((Language_Compile_TypeKind) ((*tA).u.tyTag)))) {
	TLSETL(100825);
	TLRESTORELF();
	return (1);
    };
    TLSETL(100827);
    if (((((*tA).u.tyTag) == 6) && Language_Compile_Types_IsChar((Language_Compile_TypeKind) ((*tB).u.tyTag))) || ((((*tB).u.tyTag) == 6) && Language_Compile_Types_IsChar((Language_Compile_TypeKind) ((*tB).u.tyTag)))) {
	TLSETL(100829);
	TLRESTORELF();
	return (1);
    };
    TLSETL(100832);
    if (((*tA).u.tyTag) != ((*tB).u.tyTag)) {
	TLSETL(100833);
	TLRESTORELF();
	return (0);
    };
    TLSETL(100836);
    switch ((*tA).u.tyTag) {
	case 2:
	    {
		register struct Language_Compile_IndexDef	*iA;
		register struct Language_Compile_IndexDef	*iB;
		TLSETL(100838);
		if (!Language_Compile_Types_EquivVar((*tA).u.__u7.__u8.aElementOf, (*tB).u.__u7.__u8.aElementOf)) {
		    TLSETL(100839);
		    TLRESTORELF();
		    return (0);
		};
		TLSETL(100843);
		iA = (*tA).u.__u7.__u8.IndexOf;
		TLINCL();
		iB = (*tB).u.__u7.__u8.IndexOf;
		TLSETL(100846);
		for(;;) {
		    TLSETL(100846);
		    if ((iA == ((struct Language_Compile_IndexDef *) 0)) || (iB == ((struct Language_Compile_IndexDef *) 0))) {
			break;
		    };
		    TLSETL(100847);
		    if (!Language_Compile_Types_EquivVar(iA->ty, iB->ty)) {
			TLSETL(100848);
			TLRESTORELF();
			return (0);
		    };
		    TLSETL(100850);
		    iA = iA->next;
		    TLINCL();
		    iB = iB->next;
		};
		TLSETL(100853);
		TLRESTORELF();
		return (iA == iB);
	    }
	    break;
	case 30:
	    {
		TLSETL(100856);
		TLRESTORELF();
		return (((Language_Compile_Types_EquivVar((*tA).u.__u7.__u19.Root, (*tB).u.__u7.__u19.Root) && (((*tA).u.__u7.__u19.low) == ((*tB).u.__u7.__u19.low))) && ((TLSMLSMLSETCONST(5) & (((*tA).mode) ^ ((*tB).mode))) == 0)) && ((((TLSMLSMLSETCONST(2) & ((*tA).mode)) != 0) || ((TLSMLSMLSETCONST(2) & ((*tB).mode)) != 0)) || (((*tA).u.__u7.__u19.high) == ((*tB).u.__u7.__u19.high))));
	    }
	    break;
	default :
	    {
		TLSETL(100863);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_SameType () {
    TLSTKCHKSLF(100869);
    TLSETF();
    TLSETL(100869);
    TLRESTORELF();
    return (Language_Compile_Types_Same(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)], Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_EquivVarType () {
    TLSTKCHKSLF(100874);
    TLSETF();
    TLSETL(100874);
    TLRESTORELF();
    return (Language_Compile_Types_EquivVar(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)], Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_IsScalar (ty)
struct Language_Compile_TypeDef	*ty;
{
    register struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(100879);
    TLSETF();
    TLSETL(100879);
    t = ty;
    TLSETL(100881);
    for(;;) {
	TLSETL(100881);
	if ((t->u.tyTag) != 20) {
	    break;
	};
	TLSETL(100882);
	t = t->u.__u7.__u13.tyOf;
    };
    TLSETL(100884);
    switch (t->u.tyTag) {
	case 1:
	case 3:
	case 4:
	case 13:
	case 15:
	case 16:
	case 17:
	case 19:
	case 21:
	case 22:
	case 24:
	case 30:
	case 32:
	case 0:
	    {
		TLSETL(100890);
		TLRESTORELF();
		return (1);
	    }
	    break;
	case 26:
	    {
		TLSETL(100892);
		TLRESTORELF();
		return (t->u.__u7.__u16.sIsScalar);
	    }
	    break;
	default :
	    {
		TLSETL(100894);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_StringTypes () {
    TLSTKCHKSLF(100900);
    TLSETF();
    TLSETL(100900);
    switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])) {
	case 4:
	case 5:
	case 6:
	case 27:
	    {
		TLSETL(100903);
		switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])) {
		    case 4:
		    case 5:
		    case 6:
		    case 27:
			{
			    TLSETL(100906);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    default :
			{
			    TLSETL(100908);
			    TLRESTORELF();
			    return (0);
			}
			break;
		};
	    }
	    break;
	default :
	    {
		TLSETL(100911);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_StringComparisonTypes () {
    TLSTKCHKSLF(100917);
    TLSETF();
    TLSETL(100917);
    switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])) {
	case 4:
	case 5:
	case 27:
	    {
		TLSETL(100919);
		switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])) {
		    case 4:
		    case 5:
		    case 27:
			{
			    TLSETL(100921);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    default :
			{
			    TLSETL(100923);
			    TLRESTORELF();
			    return (0);
			}
			break;
		};
	    }
	    break;
	default :
	    {
		TLSETL(100926);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_IsCondition () {
    register struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(100932);
    TLSETF();
    TLSETL(100932);
    t = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLSETL(100934);
    switch (t->u.tyTag) {
	case 9:
	case 12:
	case 11:
	case 10:
	    {
		TLSETL(100937);
		TLRESTORELF();
		return (1);
	    }
	    break;
	case 2:
	    {
		TLSETL(100940);
		t = t->u.__u7.__u8.aElementOf;
		TLINCL();
		switch (t->u.tyTag) {
		    case 9:
		    case 12:
		    case 11:
		    case 10:
			{
			    TLSETL(100945);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    default :
			{
			    TLSETL(100948);
			    TLRESTORELF();
			    return (0);
			}
			break;
		};
	    }
	    break;
	default :
	    {
		TLSETL(100952);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_IsIntType (offset)
TLint2	offset;
{
    TLSTKCHKSLF(100958);
    TLSETF();
    TLSETL(100958);
    switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - offset, 1, 30, 1)])) {
	case 16:
	case 19:
	case 0:
	    {
		TLSETL(100960);
		TLRESTORELF();
		return (1);
	    }
	    break;
	default :
	    {
		TLSETL(100962);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_TypeDef * Language_Compile_Types_RootType (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100968);
    TLSETF();
    TLSETL(100968);
    switch (ty->u.tyTag) {
	case 1:
	case 19:
	case 32:
	    {
		TLSETL(100970);
		TLRESTORELF();
		return (Language_Compile_predType[19]);
	    }
	    break;
	case 16:
	case 17:
	    {
		TLSETL(100972);
		TLRESTORELF();
		return (Language_Compile_predType[2]);
	    }
	    break;
	case 24:
	    {
		TLSETL(100974);
		TLRESTORELF();
		return (Language_Compile_predType[6]);
	    }
	    break;
	case 27:
	case 28:
	case 29:
	    {
		TLSETL(100976);
		TLRESTORELF();
		return (Language_Compile_predType[7]);
	    }
	    break;
	case 30:
	    {
		TLSETL(100978);
		TLRESTORELF();
		return (Language_Compile_Types_RootType(ty->u.__u7.__u19.Root));
	    }
	    break;
	default :
	    {
		TLSETL(100980);
		TLRESTORELF();
		return (ty);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_TypeKind Language_Compile_Types_RootTypeKind (ty)
struct Language_Compile_TypeDef	*ty;
{
    TLSTKCHKSLF(100986);
    TLSETF();
    TLSETL(100986);
    TLRESTORELF();
    return (Language_Compile_Types_RootType(ty)->u.tyTag);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Types_EnumIds () {
    TLSTKCHKSLF(100991);
    TLSETF();
    TLSETL(100991);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.__u7.__u10.EnumIds);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Types_FieldsOf () {
    TLBINDREG((*ty), struct Language_Compile___x2430);
    TLSTKCHKSLF(100996);
    TLSETF();
    TLSETL(100996);
    ty = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u);
    TLINCL();
    switch ((*ty).tyTag) {
	case 25:
	    {
		TLSETL(100999);
		TLRESTORELF();
		return ((*ty).__u7.__u15.rFieldsOf);
	    }
	    break;
	case 31:
	    {
		TLSETL(101001);
		TLRESTORELF();
		return ((*ty).__u7.__u20.uFieldsOf);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Types_Tag () {
    TLSTKCHKSLF(101007);
    TLSETF();
    TLSETL(101007);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.__u7.__u20.TagOf);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_UnionDef * Language_Compile_Types_UnionMap () {
    TLSTKCHKSLF(101012);
    TLSETF();
    TLSETL(101012);
    TLRESTORELF();
    return (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.__u7.__u20.map);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_SymbolDef * Language_Compile_Types_NameOf () {
    TLBINDREG((*ty), struct Language_Compile___x2430);
    TLSTKCHKSLF(101017);
    TLSETF();
    TLSETL(101017);
    ty = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u);
    TLINCL();
    switch ((*ty).tyTag) {
	case 7:
	case 8:
	    {
		TLSETL(101020);
		TLRESTORELF();
		return ((*ty).__u7.__u9.cNameOf);
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(101022);
		TLRESTORELF();
		return ((*ty).__u7.__u12.sNameOf);
	    }
	    break;
	case 21:
	    {
		TLSETL(101024);
		TLRESTORELF();
		return ((*ty).__u7.__u14.pNameOf);
	    }
	    break;
	default :
	    {
		TLSETL(101026);
		TLRESTORELF();
		return ((struct Language_Compile_SymbolDef *) 0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

struct Language_Compile_IndexDef * Language_Compile_Types_IndexOf () {
    TLBINDREG((*ty), struct Language_Compile___x2430);
    TLSTKCHKSLF(101032);
    TLSETF();
    TLSETL(101032);
    ty = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u);
    TLINCL();
    if (((*ty).tyTag) == 2) {
	TLSETL(101034);
	TLRESTORELF();
	return ((*ty).__u7.__u8.IndexOf);
    } else {
	TLSETL(101036);
	TLRESTORELF();
	return ((struct Language_Compile_IndexDef *) 0);
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_UnresolvedCollection () {
    register struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(101042);
    TLSETF();
    TLSETL(101042);
    ty = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    if (((ty->u.tyTag) != 21) || ((ty->u.__u7.__u14.pNameOf) == ((struct Language_Compile_SymbolDef *) 0))) {
	TLSETL(101045);
	TLRESTORELF();
	return (0);
    };
    TLSETL(101047);
    ty = ty->u.__u7.__u14.pElementOf;
    TLINCL();
    TLRESTORELF();
    return ((ty != ((struct Language_Compile_TypeDef *) 0)) && ((ty->u.tyTag) == 14));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Types_PushBaseOf () {
    TLSTKCHKSLF(101054);
    TLSETF();
    TLSETL(101054);
    Language_Compile_Types_PushType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->u.__u7.__u16.BaseOf);
    TLRESTORELF();
}

void Language_Compile_Types_ReplaceRootType () {
    struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(101058);
    TLSETF();
    TLSETL(101058);
    ty = Language_Compile_Types_RootType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLINCL();
    if (ty != (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])) {
	TLSETL(101061);
	Language_Compile_Types_FreeType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
	Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)] = ty;
    };
    TLRESTORELF();
}

void Language_Compile_Types_ReplaceSecondRootType () {
    struct Language_Compile_TypeDef	*ty;
    TLSTKCHKSLF(101067);
    TLSETF();
    TLSETL(101067);
    ty = Language_Compile_Types_RootType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
    TLINCL();
    if (ty != (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)])) {
	TLSETL(101070);
	Language_Compile_Types_FreeType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)]);
	Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = ty;
    };
    TLRESTORELF();
}

void Language_Compile_Types_ReplaceElementType () {
    TLBINDREG((*t), struct Language_Compile_TypeDef *);
    TLSTKCHKSLF(101076);
    TLSETF();
    TLSETL(101076);
    t = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLINCL();
    switch ((*t)->u.tyTag) {
	case 2:
	    {
		TLSETL(101079);
		(*t) = (*t)->u.__u7.__u8.aElementOf;
	    }
	    break;
	case 21:
	    {
		TLSETL(101081);
		(*t) = (*t)->u.__u7.__u14.pElementOf;
		TLINCL();
		if ((*t) == ((struct Language_Compile_TypeDef *) 0)) {
		    TLSETL(101085);
		    Language_Compile_CompileError_Add((TLint2) 10109, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 2);
		    (*t) = Language_Compile_predType[26];
		} else {
		    TLSETL(101086);
		    if (((*t)->u.tyTag) == 14) {
			TLSETL(101090);
			{
			    TLstring	__x2478;
			    Language_Compile_SymbolToName((*t)->typeName, __x2478);
			    Language_Compile_CompileError_Add((TLint2) 10298, &(Language_Compile_oldTok.srcPos), __x2478, "", (Language_ErrorSeverity) 2);
			};
			(*t) = Language_Compile_predType[26];
		    };
		};
	    }
	    break;
	default :
	    {
		TLSETL(101093);
		(*t) = Language_Compile_predType[26];
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Types_PushElementType () {
    register struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(101099);
    TLSETF();
    TLSETL(101099);
    t = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    switch (t->u.tyTag) {
	case 2:
	    {
		TLSETL(101104);
		Language_Compile_Types_PushType(t->u.__u7.__u8.aElementOf);
	    }
	    break;
	case 21:
	    {
		TLSETL(101105);
		t = t->u.__u7.__u14.pElementOf;
		TLINCL();
		if (t == ((struct Language_Compile_TypeDef *) 0)) {
		    TLSETL(101109);
		    Language_Compile_CompileError_Add((TLint2) 10109, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 2);
		    t = Language_Compile_predType[26];
		} else {
		    TLSETL(101110);
		    if ((t->u.tyTag) == 14) {
			TLSETL(101114);
			{
			    TLstring	__x2479;
			    Language_Compile_SymbolToName(t->typeName, __x2479);
			    Language_Compile_CompileError_Add((TLint2) 10298, &(Language_Compile_oldTok.srcPos), __x2479, "", (Language_ErrorSeverity) 2);
			};
		    };
		};
		TLSETL(101116);
		Language_Compile_Types_PushType(t);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Compile_Types_ReplacePointerType (isUnchecked)
TLboolean	isUnchecked;
{
    TLBINDREG((*t), struct Language_Compile_TypeDef *);
    TLSTKCHKSLF(101121);
    TLSETF();
    TLSETL(101121);
    t = &(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLINCL();
    switch ((*t)->u.tyTag) {
	case 7:
	case 8:
	    {
		TLSETL(101124);
		if (isUnchecked) {
		    TLSETL(101125);
		    (*t) = (*t)->u.__u7.__u9.cUPointerTy;
		} else {
		    TLSETL(101127);
		    (*t) = (*t)->u.__u7.__u9.cPointerTy;
		};
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

TLboolean Language_Compile_Types_IsNumeric (offset)
TLint2	offset;
{
    TLSTKCHKSLF(101135);
    TLSETF();
    TLSETL(101135);
    switch (Language_Compile_Types_RootTypeKind(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - offset, 1, 30, 1)])) {
	case 16:
	case 19:
	case 24:
	case 0:
	    {
		TLSETL(101137);
		TLRESTORELF();
		return (1);
	    }
	    break;
	default :
	    {
		TLSETL(101139);
		TLRESTORELF();
		return (0);
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

Language_Compile_TypeKind Language_Compile_Types_NumericKind () {
    register struct Language_Compile_TypeDef	*leftTy;
    register struct Language_Compile_TypeDef	*rightTy;
    TLSTKCHKSLF(101145);
    TLSETF();
    TLSETL(101145);
    leftTy = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)];
    TLINCL();
    if ((leftTy->u.tyTag) != 17) {
	TLSETL(101147);
	leftTy = Language_Compile_Types_RootType(leftTy);
    };
    TLSETL(101149);
    rightTy = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLINCL();
    if ((rightTy->u.tyTag) != 17) {
	TLSETL(101151);
	rightTy = Language_Compile_Types_RootType(rightTy);
    };
    TLSETL(101154);
    switch (leftTy->u.tyTag) {
	case 16:
	    {
		TLSETL(101156);
		switch (rightTy->u.tyTag) {
		    case 0:
			{
			    TLSETL(101158);
			    TLRESTORELF();
			    return (0);
			}
			break;
		    case 24:
			{
			    TLSETL(101160);
			    TLRESTORELF();
			    return (24);
			}
			break;
		    default :
			{
			    TLSETL(101162);
			    TLRESTORELF();
			    return (16);
			}
			break;
		};
	    }
	    break;
	case 17:
	    {
		TLSETL(101165);
		switch (rightTy->u.tyTag) {
		    case 0:
			{
			    TLSETL(101167);
			    TLRESTORELF();
			    return (0);
			}
			break;
		    case 19:
			{
			    TLSETL(101169);
			    TLRESTORELF();
			    return (19);
			}
			break;
		    case 24:
			{
			    TLSETL(101171);
			    TLRESTORELF();
			    return (24);
			}
			break;
		    default :
			{
			    TLSETL(101173);
			    TLRESTORELF();
			    return (16);
			}
			break;
		};
	    }
	    break;
	case 19:
	    {
		TLSETL(101176);
		switch (rightTy->u.tyTag) {
		    case 0:
			{
			    TLSETL(101178);
			    TLRESTORELF();
			    return (0);
			}
			break;
		    case 16:
			{
			    TLSETL(101180);
			    TLRESTORELF();
			    return (16);
			}
			break;
		    case 24:
			{
			    TLSETL(101182);
			    TLRESTORELF();
			    return (24);
			}
			break;
		    default :
			{
			    TLSETL(101184);
			    TLRESTORELF();
			    return (19);
			}
			break;
		};
	    }
	    break;
	default :
	    {
		TLSETL(101187);
		if ((rightTy->u.tyTag) == 0) {
		    TLSETL(101188);
		    TLRESTORELF();
		    return (0);
		} else {
		    TLSETL(101190);
		    TLRESTORELF();
		    return (leftTy->u.tyTag);
		};
	    }
	    break;
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Types_NumericType () {
    TLSTKCHKSLF(101197);
    TLSETF();
    TLSETL(101197);
    TLPRE (Language_Compile_Types_typeTop > 1);
    TLINCL();
    switch (Language_Compile_Types_NumericKind()) {
	case 0:
	    {
		TLSETL(101200);
		Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_predType[26];
	    }
	    break;
	case 16:
	    {
		TLSETL(101202);
		Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_predType[2];
	    }
	    break;
	case 19:
	    {
		TLSETL(101204);
		Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_predType[19];
	    }
	    break;
	case 24:
	    {
		TLSETL(101206);
		Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_predType[6];
	    }
	    break;
	case 27:
	    {
		TLSETL(101208);
		Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)] = Language_Compile_predType[7];
	    }
	    break;
	default :
	    break;
    };
    TLSETL(101212);
    Language_Compile_Types_Pop();
    TLRESTORELF();
}

void Language_Compile_Types_EnterMode (m)
Language_Compile_TyModes	m;
{
    TLSTKCHKSLF(101216);
    TLSETF();
    TLSETL(101216);
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->mode |= (TLSMLSMLSETCONST(TLINRANGELOW(m, 0, 9, 19)));
    TLRESTORELF();
}

void Language_Compile_Types_ClearMode (m)
Language_Compile_TyModes	m;
{
    TLSTKCHKSLF(101221);
    TLSETF();
    TLSETL(101221);
    Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->mode &= ~ (TLSMLSMLSETCONST(TLINRANGELOW(m, 0, 9, 19)));
    TLRESTORELF();
}

TLboolean Language_Compile_Types_HasMode (m)
Language_Compile_TyModes	m;
{
    TLSTKCHKSLF(101226);
    TLSETF();
    TLSETL(101226);
    TLRESTORELF();
    return ((TLSMLSMLSETCONST(TLINRANGELOW(m, 0, 9, 19)) & (Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]->mode)) != 0);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_IsDynamicType (offset)
TLint2	offset;
{
    TLBINDREG((*t), struct Language_Compile_TypeDef);
    TLSTKCHKSLF(101231);
    TLSETF();
    TLSETL(101231);
    t = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - offset, 1, 30, 1)])));
    TLSETL(101233);
    TLRESTORELF();
    return ((((TLSMLSMLSETCONST(2) & ((*t).mode)) != 0) || (((*t).u.tyTag) == 6)) || (((*t).u.tyTag) == 29));
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Compile_Types_Assignable () {
    register struct Language_Compile_TypeDef	*rFrom;
    register struct Language_Compile_TypeDef	*tTo;
    register struct Language_Compile_TypeDef	*rTo;
    TLSTKCHKSLF(101239);
    TLSETF();
    TLSETL(101239);
    rFrom = Language_Compile_Types_RootType(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)]);
    TLINCL();
    tTo = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop - 1, 1, 30, 1)];
    TLINCL();
    rTo = Language_Compile_Types_RootType(tTo);
    TLSETL(101243);
    if ((tTo->u.tyTag) == 6) {
	TLSETL(101244);
	TLRESTORELF();
	return (0);
    };
    TLSETL(101246);
    if (Language_Compile_Types_Same(rFrom, rTo)) {
	TLSETL(101247);
	TLRESTORELF();
	return (1);
    };
    TLSETL(101249);
    switch (rTo->u.tyTag) {
	case 4:
	    {
		TLSETL(101251);
		switch (rFrom->u.tyTag) {
		    case 6:
		    case 27:
			{
			    TLSETL(101253);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    case 5:
			{
			    TLSETL(101255);
			    TLRESTORELF();
			    return ((rFrom->u.__u7.__u17.stringSize) == 1);
			}
			break;
		    default :
			break;
		};
	    }
	    break;
	case 5:
	    {
		TLSETL(101259);
		switch (rFrom->u.tyTag) {
		    case 4:
			{
			    TLSETL(101262);
			    TLRESTORELF();
			    return ((tTo->u.__u7.__u17.stringSize) == 1);
			}
			break;
		    case 6:
		    case 27:
			{
			    TLSETL(101264);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    case 5:
			{
			    TLSETL(101266);
			    TLRESTORELF();
			    return ((tTo->u.__u7.__u17.stringSize) == (rFrom->u.__u7.__u17.stringSize));
			}
			break;
		    default :
			break;
		};
	    }
	    break;
	case 16:
	case 19:
	case 24:
	    {
		TLSETL(101271);
		TLRESTORELF();
		return (((rFrom->u.tyTag) == 16) || ((rFrom->u.tyTag) == 19));
	    }
	    break;
	case 21:
	    {
		TLSETL(101274);
		if ((rFrom->u.tyTag) == 21) {
		    TLSETL(101276);
		    if ((rFrom->u.__u7.__u14.pElementOf) == ((struct Language_Compile_TypeDef *) 0)) {
			TLSETL(101278);
			TLRESTORELF();
			return (1);
		    };
		    TLSETL(101280);
		    if ((rTo->u.__u7.__u14.pElementOf) != ((struct Language_Compile_TypeDef *) 0)) {
			TLSETL(101281);
			if (((rFrom->u.__u7.__u14.pElementOf->u.tyTag) == 0) || ((rTo->u.__u7.__u14.pElementOf->u.tyTag) == 0)) {
			    TLSETL(101286);
			    TLRESTORELF();
			    return (1);
			};
			TLSETL(101288);
			if (((rFrom->u.__u7.__u14.pElementOf->u.tyTag) == 7) && ((rTo->u.__u7.__u14.pElementOf->u.tyTag) == 7)) {
			    TLSETL(101298);
			    TLRESTORELF();
			    return (Language_Compile_Scope_AncestorOf(rTo->u.__u7.__u14.pNameOf, rFrom->u.__u7.__u14.pNameOf) || Language_Compile_Scope_AncestorOf(rFrom->u.__u7.__u14.pNameOf, rTo->u.__u7.__u14.pNameOf));
			};
		    };
		};
	    }
	    break;
	case 27:
	    {
		TLSETL(101306);
		switch (rFrom->u.tyTag) {
		    case 4:
		    case 5:
		    case 6:
			{
			    TLSETL(101308);
			    TLRESTORELF();
			    return (1);
			}
			break;
		    default :
			break;
		};
	    }
	    break;
	default :
	    break;
    };
    TLSETL(101313);
    TLRESTORELF();
    return (0);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

static TLint4 Language_Compile_Types_SmallestPackedSize () {
    register struct Language_Compile_TypeDef	*t;
    TLSTKCHKSLF(101318);
    TLSETF();
    TLSETL(101318);
    t = Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)];
    TLSETL(101320);
    if ((t->u.tyTag) == 13) {
	register struct Language_Compile_SymbolDef	*s;
	register TLint4	count;
	TLSETL(101321);
	s = t->u.__u7.__u10.EnumIds;
	TLINCL();
	count = 0;
	TLSETL(101324);
	for(;;) {
	    TLSETL(101324);
	    if (s == ((struct Language_Compile_SymbolDef *) 0)) {
		break;
	    };
	    TLSETL(101325);
	    count += 1;
	    TLINCL();
	    s = s->next;
	};
	TLSETL(101328);
	count -= 1;
	TLINCL();
	if (count <= 255) {
	    TLSETL(101330);
	    TLRESTORELF();
	    return (1);
	} else {
	    TLSETL(101331);
	    if (count <= 65535) {
		TLSETL(101332);
		TLRESTORELF();
		return (2);
	    } else {
		TLSETL(101334);
		TLRESTORELF();
		return (4);
	    };
	};
    } else {
	TLSETL(101336);
	if ((t->u.tyTag) == 30) {
	    TLint4	low;
	    TLint4	high;
	    TLSETL(101337);
	    low = t->u.__u7.__u19.low;
	    TLINCL();
	    high = t->u.__u7.__u19.high;
	    TLSETL(101340);
	    if ((low >= (- (127 + 1))) && (high <= 127)) {
		TLSETL(101341);
		TLRESTORELF();
		return (1);
	    } else {
		TLSETL(101342);
		if ((low >= (- (32767 + 1))) && (high <= 32767)) {
		    TLSETL(101343);
		    TLRESTORELF();
		    return (2);
		} else {
		    TLSETL(101345);
		    TLRESTORELF();
		    return (4);
		};
	    };
	} else {
	    TLSETL(101348);
	    TLRESTORELF();
	    return (t->tSize);
	};
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Compile_Types_EnterStorageSize (sz)
TLint4	sz;
{
    TLSTKCHKSLF(101354);
    TLSETF();
    TLSETL(101354);
    if ((sz < 1) || (sz > 4)) {
	TLSETL(101357);
	Language_Compile_CompileError_Add((TLint2) 10158, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 1);
    } else {
	TLint4	Size;
	TLBINDREG((*t), struct Language_Compile_TypeDef);
	TLSETL(101360);
	if (sz < Language_Compile_Types_SmallestPackedSize()) {
	    TLSETL(101363);
	    Language_Compile_CompileError_Add((TLint2) 10224, &(Language_Compile_oldTok.srcPos), "", "", (Language_ErrorSeverity) 1);
	    Size = Language_Compile_Types_SmallestPackedSize();
	} else {
	    TLSETL(101365);
	    Size = sz;
	};
	TLSETL(101368);
	t = &((*(Language_Compile_Types_typeStack[TLINRANGELOW(Language_Compile_Types_typeTop, 1, 30, 1)])));
	TLSETL(101370);
	if ((TLSMLSMLSETCONST(9) & ((*t).mode)) == 0) {
	    TLSETL(101373);
	    TLRESTORELF();
	    return;
	};
	TLSETL(101375);
	(*t).tSize = Size;
	TLINCL();
	(*t).mode &= ~ 0x200;
	TLINCL();
	switch (Size) {
	    case 1:
		{
		    TLSETL(101379);
		    (*t).alignment = 1;
		}
		break;
	    case 2:
		{
		    TLSETL(101381);
		    (*t).alignment = 2;
		}
		break;
	    case 4:
		{
		    TLSETL(101383);
		    (*t).alignment = 4;
		}
		break;
	    default:
		TLCASEABORT;
	};
    };
    TLRESTORELF();
}

void Language_Compile_Types_Pack () {
    TLSTKCHKSLF(101391);
    TLSETF();
    TLSETL(101391);
    Language_Compile_Types_EnterStorageSize((TLint4) Language_Compile_Types_SmallestPackedSize());
    TLRESTORELF();
}

static void Language_Compile_Types_OutputTypeAttributes (attr, file)
Language_Compile_TyModesSet	attr;
TLint4	file;
{
    TLSTKCHKSLF(101396);
    TLSETF();
    TLSETL(101396);
    if (attr != 0) {
	TLboolean	first;
	TLSETL(101397);
	first = 1;
	TLINCL();
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "<", (TLint2) file);
	TLINCL();
	{
	    register TLint4	i;
	    for (i = 0; i <= 9; i++) {
		TLSETL(101400);
		if ((TLSMLSMLSETCONST(TLINRANGELOW(i, 0, 9, 19)) & attr) != 0) {
		    TLSETL(101401);
		    if (first) {
			TLSETL(101402);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_TyModeName[TLINRANGELOW(i, 0, 9, 1)]), (TLint2) file);
			TLINCL();
			first = 0;
		    } else {
			TLSETL(101405);
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
			TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_TyModeName[TLINRANGELOW(i, 0, 9, 1)]), (TLint2) file);
		    };
		};
	    };
	};
	TLSETL(101409);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "> ", (TLint2) file);
    };
    TLRESTORELF();
}

static void Language_Compile_Types_DumpEnumList (sy, file, indent)
struct Language_Compile_SymbolDef	*sy;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_SymbolDef	*s;
    TLSTKCHKSLF(101415);
    TLSETF();
    TLSETL(101415);
    s = sy;
    TLSETL(101418);
    for(;;) {
	TLSETL(101418);
	if (s == ((struct Language_Compile_SymbolDef *) 0)) {
	    break;
	};
	TLSETL(101420);
	Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, (s->identPtr->str), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, " (", (TLint2) file);
	TL_TLI_TLIPI ((TLint4) 0, (TLint4) Language_Compile_Value_IntValue(s->u.__u1.__u3.cValue), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
	TLSETL(101422);
	s = s->next;
    };
    TLRESTORELF();
}

static void Language_Compile_Types_DumpIndexList (ty, file, indent)
struct Language_Compile_IndexDef	*ty;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_IndexDef	*t;
    TLSTKCHKSLF(101428);
    TLSETF();
    TLSETL(101428);
    t = ty;
    TLSETL(101430);
    for(;;) {
	TLSETL(101430);
	if (t == ((struct Language_Compile_IndexDef *) 0)) {
	    break;
	};
	TLSETL(101432);
	Language_Compile_Types_DumpType(t->ty, (TLint4) file, (TLnat4) indent);
	t = t->next;
    };
    TLRESTORELF();
}

static void Language_Compile_Types_DumpUnionMap (un, file, indent)
struct Language_Compile_UnionDef	*un;
TLint4	file;
TLnat4	indent;
{
    register struct Language_Compile_UnionDef	*u;
    TLSTKCHKSLF(101438);
    TLSETF();
    TLSETL(101438);
    u = un;
    TLSETL(101441);
    for(;;) {
	register struct Language_Compile_IntListDef	*i;
	TLSETL(101441);
	if (u == ((struct Language_Compile_UnionDef *) 0)) {
	    break;
	};
	TLSETL(101443);
	Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPI ((TLint4) 0, (TLint4) (u->numSyms), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, " symbols", (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
	TLINCL();
	i = u->values;
	TLSETL(101447);
	for(;;) {
	    TLSETL(101447);
	    if (i == ((struct Language_Compile_IntListDef *) 0)) {
		break;
	    };
	    TLSETL(101449);
	    Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
	    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	    TL_TLI_TLIPI ((TLint4) 0, (TLint4) (i->value), (TLint2) file);
	    TL_TLI_TLIPK ((TLint2) file);
	    TLINCL();
	    i = i->next;
	};
	TLSETL(101452);
	u = u->next;
    };
    TLRESTORELF();
}

void Language_Compile_Types_DumpType (ty, file, indent)
struct Language_Compile_TypeDef	*ty;
TLint4	file;
TLnat4	indent;
{
    TLSTKCHKSLF(101459);
    TLSETF();
    TLSETL(101459);
    Language_Compile_OutputIndent((TLint4) file, (TLnat4) indent);
    if (ty == ((struct Language_Compile_TypeDef *) 0)) {
	TLSETL(101460);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "(nil type)", (TLint2) file);
	TL_TLI_TLIPK ((TLint2) file);
	TLSETL(101462);
	TLRESTORELF();
	return;
    };
    TLSETL(101463);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_TypeKindName[TLINRANGELOW(ty->u.tyTag, 0, 32, 1)]), (TLint2) file);
    TL_TLI_TLIPS ((TLint4) 0, " ", (TLint2) file);
    TLINCL();
    if ((ty->typeName) != ((struct Language_Compile_SymbolDef *) 0)) {
	TLSETL(101465);
	TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
	TL_TLI_TLIPS ((TLint4) 0, "\"", (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, (ty->typeName->identPtr->str), (TLint2) file);
	TL_TLI_TLIPS ((TLint4) 0, "\" ", (TLint2) file);
    };
    TLSETL(101469);
    Language_Compile_Types_OutputTypeAttributes((Language_Compile_TyModesSet) (ty->mode), (TLint4) file);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPI ((TLint4) 6, (TLint4) (ty->tSize), (TLint2) file);
    TL_TLI_TLIPI ((TLint4) 6, (TLint4) (ty->alignment), (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLINCL();
    switch (ty->u.tyTag) {
	case 2:
	    {
		TLSETL(101473);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "descriptor @ (", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_BaseName[TLINRANGELOW(ty->u.__u7.__u8.aDescriptor.base, 0, 9, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_IndirName[TLINRANGELOW(ty->u.__u7.__u8.aDescriptor.indir, 0, 2, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPN ((TLint4) 0, (TLnat4) (ty->u.__u7.__u8.aDescriptor.offset), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
		TLSETL(101478);
		Language_Compile_Types_DumpIndexList(ty->u.__u7.__u8.IndexOf, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101480);
		Language_Compile_Types_DumpType(ty->u.__u7.__u8.aElementOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 5:
	case 28:
	    {
		TLSETL(101482);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "upper = ", (TLint2) file);
		TL_TLI_TLIPI ((TLint4) 0, (TLint4) (ty->u.__u7.__u17.stringSize), (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
	    }
	    break;
	case 6:
	case 29:
	    {
		TLSETL(101486);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "descriptor @ (", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_BaseName[TLINRANGELOW(ty->u.__u7.__u18.sDescriptor.base, 0, 9, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_IndirName[TLINRANGELOW(ty->u.__u7.__u18.sDescriptor.indir, 0, 2, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPN ((TLint4) 0, (TLnat4) (ty->u.__u7.__u18.sDescriptor.offset), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
	    }
	    break;
	case 8:
	    {
		TLSETL(101494);
		Language_Compile_Types_DumpType(ty->u.__u7.__u9.cPointerTy, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 13:
	    {
		TLSETL(101496);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "descriptor @ (", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_BaseName[TLINRANGELOW(ty->u.__u7.__u10.eDescriptor.base, 0, 9, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_IndirName[TLINRANGELOW(ty->u.__u7.__u10.eDescriptor.indir, 0, 2, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPN ((TLint4) 0, (TLnat4) (ty->u.__u7.__u10.eDescriptor.offset), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
		TLSETL(101502);
		Language_Compile_Types_DumpEnumList(ty->u.__u7.__u10.EnumIds, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 15:
	case 22:
	case 23:
	    {
		TLSETL(101505);
		(*Language_Compile_procDumpSym)(ty->u.__u7.__u12.sNameOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 20:
	    {
		TLSETL(101508);
		Language_Compile_Types_DumpType(ty->u.__u7.__u13.tyOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 21:
	    {
		TLSETL(101509);
		if ((ty->u.__u7.__u14.pNameOf) != ((struct Language_Compile_SymbolDef *) 0)) {
		    TLSETL(101511);
		    Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) 0, "pointer to ", (TLint2) file);
		    TL_TLI_TLIPS ((TLint4) 0, (ty->u.__u7.__u14.pNameOf->identPtr->str), (TLint2) file);
		    TL_TLI_TLIPK ((TLint2) file);
		    TLSETL(101513);
		    if ((ty->u.__u7.__u14.pElementOf) != ty) {
			TLSETL(101515);
			Language_Compile_Types_DumpType(ty->u.__u7.__u14.pElementOf, (TLint4) file, (TLnat4) (indent + 4));
		    };
		} else {
		    TLSETL(101516);
		    if ((ty->u.__u7.__u14.pElementOf) != ((struct Language_Compile_TypeDef *) 0)) {
			TLSETL(101518);
			Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
			TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
			TL_TLI_TLIPS ((TLint4) 0, "pointer to (type)", (TLint2) file);
			TL_TLI_TLIPK ((TLint2) file);
			TLINCL();
			if ((ty->u.__u7.__u14.pElementOf) != ty) {
			    TLSETL(101521);
			    Language_Compile_Types_DumpType(ty->u.__u7.__u14.pElementOf, (TLint4) file, (TLnat4) (indent + 4));
			};
		    };
		};
	    }
	    break;
	case 25:
	    {
		TLSETL(101527);
		(*Language_Compile_procDumpSymList)(ty->u.__u7.__u15.rFieldsOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 26:
	    {
		TLSETL(101529);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		if (ty->u.__u7.__u16.sIsScalar) {
		    TLSETL(101530);
		    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) 0, "(scalar)", (TLint2) file);
		    TL_TLI_TLIPK ((TLint2) file);
		} else {
		    TLSETL(101532);
		    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) 0, "(nonscalar)", (TLint2) file);
		    TL_TLI_TLIPK ((TLint2) file);
		};
		TLSETL(101536);
		Language_Compile_Types_DumpType(ty->u.__u7.__u16.BaseOf, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 30:
	    {
		TLSETL(101538);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPI ((TLint4) 0, (TLint4) (ty->u.__u7.__u19.low), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, " .. ", (TLint2) file);
		TL_TLI_TLIPI ((TLint4) 0, (TLint4) (ty->u.__u7.__u19.high), (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
		TLSETL(101541);
		Language_Compile_Types_DumpType(ty->u.__u7.__u19.Root, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	case 31:
	    {
		TLSETL(101543);
		Language_Compile_OutputIndent((TLint4) file, (TLnat4) (indent + 4));
		TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "map @ (", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_BaseName[TLINRANGELOW(ty->u.__u7.__u20.mapLocation.base, 0, 9, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, (Language_Compile_IndirName[TLINRANGELOW(ty->u.__u7.__u20.mapLocation.indir, 0, 2, 1)]), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ",", (TLint2) file);
		TL_TLI_TLIPN ((TLint4) 0, (TLnat4) (ty->u.__u7.__u20.mapLocation.offset), (TLint2) file);
		TL_TLI_TLIPS ((TLint4) 0, ")", (TLint2) file);
		TL_TLI_TLIPK ((TLint2) file);
		TLSETL(101548);
		(*Language_Compile_procDumpSym)(ty->u.__u7.__u20.TagOf, (TLint4) file, (TLnat4) (indent + 4));
		TLINCL();
		(*Language_Compile_procDumpSymList)(ty->u.__u7.__u20.uFieldsOf, (TLint4) file, (TLnat4) (indent + 4));
		TLSETL(101551);
		Language_Compile_Types_DumpUnionMap(ty->u.__u7.__u20.map, (TLint4) file, (TLnat4) (indent + 4));
	    }
	    break;
	default :
	    break;
    };
    TLRESTORELF();
}

void Language_Compile_Types_DumpTypeStack (file)
TLint4	file;
{
    TLSTKCHKSLF(101557);
    TLSETF();
    TLSETL(101557);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "Type Stack Dump:", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLINCL();
    {
	register TLint4	t;
	for (t = Language_Compile_Types_typeTop; t >= 1; t--) {
	    TLSETL(101560);
	    Language_Compile_Types_DumpType(Language_Compile_Types_typeStack[TLINRANGELOW(t, 1, 30, 1)], (TLint4) file, (TLnat4) 0);
	};
    };
    TLSETL(101561);
    TL_TLI_TLISS ((TLint4) file, (TLint2) 2);
    TL_TLI_TLIPS ((TLint4) 0, "", (TLint2) file);
    TL_TLI_TLIPK ((TLint2) file);
    TLRESTORELF();
}

void Language_Compile_Types_AssertStackEmpty () {
    TLSTKCHKSLF(101566);
    TLSETF();
    TLSETL(101566);
    TLASSERT (Language_Compile_Types_typeTop == 0);
    TLRESTORELF();
}

void Language_Compile_Types_Initialize () {
    TLSTKCHKSLF(101572);
    TLSETF();
    TLSETL(101572);
    Language_Compile_Types_typeTop = 0;
    TLINCL();
    Language_Compile_Types_freeTypeChain = (struct Language_Compile_TypeDef *) 0;
    TLRESTORELF();
}

void Language_Compile_Types () {
    TLSAVELF();
    TLSETF();
    TLSETL(100054);
    {
	register TLint4	i;
	for (i = 0; i <= 26; i++) {
	    register struct Language_Compile_TypeDef	*ty;
	    TLSETL(100055);
	    TL_TLB_TLBNWU(& Language_Compile_predType[TLINRANGELOW(i, 0, 26, 1)], (TLint4)  sizeof (	    struct Language_Compile_TypeDef));
	    TLSETL(100057);
	    ty = Language_Compile_predType[TLINRANGELOW(i, 0, 26, 1)];
	    TLSETL(100059);
	    ty->u.tyTag = Language_Compile_PredTypeKind[TLINRANGELOW(i, 0, 26, 1)];
	    TLINCL();
	    ty->typeName = (struct Language_Compile_SymbolDef *) 0;
	    TLINCL();
	    ty->mode = Language_Compile_PredTypeMode[TLINRANGELOW(i, 0, 26, 1)];
	    TLINCL();
	    ty->tSize = Language_Compile_Types_pSize[TLINRANGELOW(i, 0, 26, 1)];
	    TLINCL();
	    ty->alignment =  TLRANGECHECK (Language_Compile_Types_pAlignment[TLINRANGELOW(i, 0, 26, 1)], 0, 4, 5);
	    TLINCL();
	    TLSTRCTASS(ty->uninitTableLoc, Language_Compile_nullLocation, struct Language_Compile_Location);
	    TLSETL(100066);
	    switch (i) {
		case 4:
		    {
			TLSETL(100068);
			ty->u.__u7.__u14.pNameOf = (struct Language_Compile_SymbolDef *) 0;
			TLINCL();
			ty->u.__u7.__u14.pElementOf = (struct Language_Compile_TypeDef *) 0;
		    }
		    break;
		case 5:
		    {
			TLSETL(100071);
			ty->u.__u7.__u12.sNameOf = (struct Language_Compile_SymbolDef *) 0;
		    }
		    break;
		case 8:
		    {
			TLSETL(100073);
			ty->u.__u7.__u17.stringSize = 1;
		    }
		    break;
		default :
		    break;
	    };
	};
    };
    TLSETL(100085);
    Language_Compile_Types_freeTypeChain = (struct Language_Compile_TypeDef *) 0;
    TLRESTORELF();
}
