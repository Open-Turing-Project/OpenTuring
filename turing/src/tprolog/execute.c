#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[1769];
} TLFTAB =
    { 31,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', '.', '.', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'E', 'x', 'e', 'c', 'E', 'r', 'r', 'B', 'o', 'd', 'y', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'k', 'e', 'r', 'n', 'e', 'l', 'T', 'y', 'p', 'e', 's', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'h', 'a', 'n', 'd', 'l', 'e', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'm', 'o', 'n', 'i', 't', 'o', 'r', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'k', 'e', 'r', 'n', 'e', 'l', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 's', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'h', 'e', 'a', 'p', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'M', 'I', 'O', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'k', 'e', 'r', 'n', 'e', 'l', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'a', 't', 'h', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 't', 'r', 'i', 'n', 'g', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'S', 'y', 's', 't', 'e', 'm', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'L', 'i', 'm', 'i', 't', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'G', 'r', 'a', 'p', 'h', 'i', 'c', 's', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'E', 'v', 'e', 'n', 't', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 'M', 'T', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 'c', '_', 'e', 'x', 't', 'e', 'r', 'n', 'a', 'l', '/', 's', 't', 'a', 'r', '/', 'S', 't', 'a', 'r', '.', 'c', 'h', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'r', 'u', 'n', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 's', 'y', 's', 't', 'e', 'm', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1631[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1631	text;
};
typedef	TLstring	__x1632[20];

extern void Language_EnterPreprocSymbols ();
typedef	TLstring	__x1635[21];

extern void Language_SetupExecutionFromObjectFile ();

extern void Language_GetFileName ();
typedef	TLstring	__x1639[21];
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    TLint4	moreStateInfo;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

extern void Language_ExecuteProgram ();

extern void Language_EndExecution ();

extern void Language_StopExecution ();
extern struct SrcPosition	Language_nullSrcPosition;
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
extern TLint4	Language_codeOprSize;
extern TLint4	Language_codeInt1Size;
extern TLint4	Language_codeInt2Size;
extern TLint4	Language_codeIntSize;
extern TLint4	Language_codeRealSize;
extern TLint4	Language_codeAddrSize;
extern TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1643 {
    TLint4	lower, range;
};
typedef	struct Language___x1643	Language___x1642[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1642	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1644[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1644	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1645[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1645	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;
typedef	TLstring	__x1648[21];

void Language_Execute_Initialize ();

TLint4 Language_Execute_GetStackAllocated ();

void Language_Execute_Executor ();

void Language_Execute_EndExecution ();

void Language_Execute_RecoverAllMemory ();
TLint2	Language_Execute_executionTimeout;
TLboolean	Language_Execute_externalExecutionTimeoutFlag;
TLint4	Language_Execute_stackAllocated;
TLboolean	Language_Execute_allWaitingForKeyboard;
TLboolean	Language_Execute_allWaitingForMouse;
TLboolean	Language_Execute_allWaitingForDelay;
TLint4	Language_Execute_minimumDelayCount;

extern void TL_TLB_TLBUUN ();

extern void TL_TLB_TLBUNI ();

extern void strcpy ();
typedef	TLint2	Language_Execute_ExecutionError_OverflowKind;
static TLint4	Language_Execute_ExecutionError_savedQuitCode;
static TLstring	Language_Execute_ExecutionError_savedMessage;

void Language_Execute_ExecutionError_Abort (quitCode, message)
TLint4	quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1200018);
    TLSETF();
    TLSETL(1200018);
    Language_Execute_ExecutionError_savedQuitCode = quitCode;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, message);
    TLINCL();
    TL_TLE_TLEQUIT ((TLint4) 2, (char *) 0, 0);
    TLRESTORELF();
}
static Language_Execute_ExecutionError_OverflowKind	Language_Execute_ExecutionError_overflowKind;

void Language_Execute_ExecutionError_SetOverflowKind (kind)
Language_Execute_ExecutionError_OverflowKind	kind;
{
    TLSTKCHKSLF(1200029);
    TLSETF();
    TLSETL(1200029);
    Language_Execute_ExecutionError_overflowKind = kind;
    TLRESTORELF();
}
typedef	TLnat4	Language_Execute_ExecutionError_TL_priority_t;
struct	Language_Execute_ExecutionError_TL_ExceptionInfo {
    TLint4	quitCode;
    TLint4	libraryQuitCode;
    TLstring	errorMsg;
};
typedef	TLnat1	Language_Execute_ExecutionError___x1651[1];
struct	Language_Execute_ExecutionError_TL_HandlerArea {
    TLint4	quitCode;
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*nextHandler;
    Language_Execute_ExecutionError___x1651	savedState;
};
typedef	TLnat4	Language_Execute_ExecutionError_TL_hardwarePriority_t;
typedef	Language_Execute_ExecutionError_TL_hardwarePriority_t	Language_Execute_ExecutionError_TL_lockStatus_t;
typedef	TLnat4	Language_Execute_ExecutionError_TL_lock_t;
struct	Language_Execute_ExecutionError_TL_link_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*flink;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*blink;
};
struct	Language_Execute_ExecutionError_TL_ProcessDescriptor {
    TLnat4	lineAndFile;
    TLaddressint	fileTable;
    TLaddressint	stackLimit;
    TLaddressint	stackPointer;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*handlerQhead;
    struct Language_Execute_ExecutionError_TL_HandlerArea	*currentHandler;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ExceptionInfo	exception;
    TLnat4	waitParameter;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*monitorQlink;
    TLnat4	timeOutStatus;
    TLnat4	pid;
    TLaddressint	memoryBase;
    TLnat4	timeoutTime;
    TLnat4	timeoutEpoch;
    struct Language_Execute_ExecutionError_TL_link_t	timeoutQ;
    TLboolean	timedOut;
    TLboolean	pausing;
    Language_Execute_ExecutionError_TL_priority_t	dispatchPriority;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*runQlink;
    TLboolean	ready;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tsyncWaiter;
    TLnat4	quantum;
    TLnat4	quantumCntr;
    TLnat4	devmonLevel;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_queue_t {
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*head;
    struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*tail;
};
struct	Language_Execute_ExecutionError_TL_MonitorDescriptor {
    Language_Execute_ExecutionError_TL_lock_t	mQLock;
    TLint4	entryParameter;
    TLint4	monitorPriority;
    TLboolean	deviceMonitor;
    struct Language_Execute_ExecutionError_TL_queue_t	entryQ;
    struct Language_Execute_ExecutionError_TL_queue_t	reEntryQ;
    TLaddressint	name;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*firstCondition;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*prevMonitor;
    TLaddressint	otherInfo;
};
struct	Language_Execute_ExecutionError_TL_ConditionDescriptor {
    struct Language_Execute_ExecutionError_TL_queue_t	signalQ;
    struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*md;
    TLaddressint	name;
    TLnat4	index;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*nextCondition;
    struct Language_Execute_ExecutionError_TL_ConditionDescriptor	*prevCondition;
    TLaddressint	otherInfo;
};
typedef	struct Language_Execute_ExecutionError_TL_ConditionDescriptor	Language_Execute_ExecutionError___x1654[65535];
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLKPD;
extern struct Language_Execute_ExecutionError_TL_ProcessDescriptor	*TL_TLK_TLKTQH;
extern struct Language_Execute_ExecutionError_TL_MonitorDescriptor	*TL_TLM_TLMMLH;

void Language_Execute_ExecutionError_GetAbort (quitCode, message)
TLint4	*quitCode;
TLstring	message;
{
    TLSTKCHKSLF(1200043);
    TLSETF();
    TLSETL(1200043);
    if ((*quitCode) == 2) {
	TLSETL(1200044);
	(*quitCode) = Language_Execute_ExecutionError_savedQuitCode;
	TLINCL();
	TLSTRASS(255, message, Language_Execute_ExecutionError_savedMessage);
    } else {
	TLSETL(1200046);
	if ((*quitCode) == 51) {
	    TLSETL(1200047);
	    if (Language_Execute_ExecutionError_overflowKind == 1) {
		TLSETL(1200048);
		TLSTRASS(255, message, "Overflow in real \'mod\' operation");
	    } else {
		TLSETL(1200049);
		if (Language_Execute_ExecutionError_overflowKind == 2) {
		    TLSETL(1200050);
		    TLSTRASS(255, message, "Overflow in real \'div\' operation");
		} else {
		    TLSETL(1200055);
		    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
		};
	    };
	} else {
	    TLSETL(1200063);
	    TLSTRASS(255, message, TL_TLKPD->exception.errorMsg);
	};
    };
    TLRESTORELF();
}

void Language_Execute_ExecutionError_Initialize () {
    TLSTKCHKSLF(1200072);
    TLSETF();
    TLSETL(1200072);
    Language_Execute_ExecutionError_savedQuitCode = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_ExecutionError_savedMessage, "");
    TLINCL();
    Language_Execute_ExecutionError_overflowKind = 0;
    TLRESTORELF();
}

void ExecutionError () {
    TLSAVELF();
    TLSETF();
    TLRESTORELF();
}

extern void Language_Execute_Heap_Alloc ();

extern void Language_Execute_Heap_CleanUp ();

extern void Language_Execute_Heap_Dealloc ();

extern void Language_Execute_Heap_Free ();

extern void Language_Execute_Heap_New ();

extern void Language_Execute_Heap_Realloc ();
typedef	TLint1	MIO_EventMode;
struct	MIO_EventDescriptor {
    MIO_EventMode	mode;
    TLint4	count;
    TLaddressint    data;
};

extern TLboolean MIO_HasEvent ();

extern TLboolean MIO_SetActive ();

extern void MIO_NextEvent ();

extern void MIO_SetEvents ();

extern void MIO_GetEvent ();
typedef	TLchar	__x1655[4];

extern void MIO_KeyTranslate ();

extern TLchar MIO_Getch ();

extern TLboolean MIO_Hasch ();

extern void MIO_Clip ();

extern void MIO_ClipOff ();

extern void MIO_Clear ();

extern TLint4 MIO_ColourNum ();

extern void MIO_DrawArc ();

extern void MIO_DrawBox ();

extern void MIO_DrawDot ();

extern void MIO_DrawFill ();

extern void MIO_DrawFillArc ();

extern void MIO_DrawFillBox ();

extern void MIO_DrawFillOval ();

extern void MIO_DrawFillPolygon ();

extern void MIO_DrawLine ();

extern void MIO_DrawOval ();

extern void MIO_DrawPic ();

extern void MIO_DrawPolygon ();

extern void MIO_DrawText ();

extern void MIO_DrawTextSize ();

extern TLint4 MIO_FontNum ();

extern void MIO_GetColour ();

extern TLint4 MIO_GetDotColour ();

extern void MIO_GetGraphMax ();

extern TLint4 MIO_GetMaxColour ();

extern TLint4 MIO_GetMaxFont ();

extern TLint4 MIO_GetPalette ();

extern void MIO_GetPos ();

extern void MIO_GetRgb ();

extern void MIO_GetScreenSize ();

extern void MIO_GetTextChar ();

extern TLint4 MIO_GetTextFont ();

extern void MIO_GetTextMax ();

extern void MIO_NumColour ();

extern void MIO_NumFont ();

extern void MIO_SetBackgroundColour ();

extern void MIO_SetPalette ();

extern void MIO_SetPos ();

extern void MIO_SetPosXY ();

extern void MIO_SetRgb ();

extern void MIO_SetTextBackgroundColour ();

extern void MIO_SetTextColour ();

extern void MIO_SetTextFont ();

extern TLint4 MIO_SizePic ();

extern void MIO_TakePic ();

extern void MIO_Init ();

extern void MIO_End ();

extern void MIO_Mode ();

extern void MIO_Delay ();

extern void MIO_PlaySound ();

extern void MIO_Play ();

extern TLboolean MIO_PlayDone ();

extern void MIO_RegisterOpen ();

extern void MIO_RegisterClose ();
TLnat2	Language_Execute_numArguments;
typedef	TLint1	Language_Execute___x1656[23];
Language_Execute___x1656	Language_Execute_fileMap;
typedef	Language_StringDef	*Language_Execute___x1659[21];
Language_Execute___x1659	Language_Execute_argumentNames;
static TLnat2	Language_Execute_numFilesOpen;
extern TLboolean	TL_TLI_TLIUXS;
extern TLint4	TL_TLI_TLIXSN;

extern void TL_TLI_TLIOF ();

extern void TL_TLI_TLISS ();

extern void TL_TLI_TLIPC ();

extern void TL_TLI_TLIGC ();

extern TLaddressint TL_TLI_TLIGF ();
struct	Language_Execute_LibraryAbort {
    TLint4	quitCode;
    TLstring	errorMsg;
};
struct	Language_Execute_SavedRegisters {
    TLaddressint	fp;
    TLaddressint	sp;
};
struct	Language_Execute_HandlerArea {
    TLint4	quitCode;
    struct SrcPosition	srcPos;
    struct Language_Execute_HandlerArea	*nextHandler;
    TLaddressint	handlerRoutine;
    struct Language_Execute_SavedRegisters	savedRegisters;
};
struct	Language_Execute_PendingEvent {
    TLint4	stream;
    struct MIO_EventDescriptor	event;
};
struct	Language_Execute_ProcessDescriptor {
    TLaddressint	pc;
    TLaddressint	fp;
    TLaddressint	sp;
    TLaddressint	minimumSP;
    TLaddressint	stackBase;
    struct SrcPosition	srcPos;
    TLint4	activeStream;
    struct Language_Execute_PendingEvent	pendingEvent;
    struct Language_Execute_LibraryAbort	abort;
    TLint4	errno;
    TLstring	errMessage;
    TLint4	prevErrno;
    TLstring	prevErrMessage;
    TLaddressint	name;
    struct Language_Execute_ProcessDescriptor	*nextProcess;
    TLint4	dispatchPriority;
    TLnat4	waitParameter;
    struct Language_Execute_ConditionDescriptor	*waitCondition;
    struct Language_Execute_ProcessDescriptor	*nextTimeout;
    TLnat4	totalPause;
    struct Language_Execute_HandlerArea	*activeHandler;
    struct Language_Execute_HandlerArea	*runningHandler;
};
struct	Language_Execute_MonitorDescriptor {
    TLint2	entryParameter;
    TLint2	monitorPriority;
    struct Language_Execute_ProcessDescriptor	*entryHead;
    struct Language_Execute_ProcessDescriptor	*entryTail;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*firstCondition;
    struct Language_Execute_MonitorDescriptor	*nextMonitor;
    struct Language_Execute_MonitorDescriptor	*prevMonitor;
};
struct	Language_Execute_ConditionDescriptor {
    struct Language_Execute_ProcessDescriptor	*signalHead;
    struct Language_Execute_ProcessDescriptor	*signalTail;
    struct Language_Execute_MonitorDescriptor	*md;
};
typedef	struct Language_Execute_ConditionDescriptor	Language_Execute___x1660[65535];
struct	Language_Execute_ConditionDefinition {
    TLnat2	cdArraySize;
    Language_Execute___x1660	*cdArray;
    TLaddressint	name;
    struct Language_Execute_ConditionDefinition	*nextVariable;
};
struct Language_Execute_ProcessDescriptor	*Language_Execute_RQHead;
struct Language_Execute_ProcessDescriptor	*Language_Execute_EQHead;
TLnat4	Language_Execute_Chrono;
TLint4	Language_Execute_processCount;
TLaddressint	Language_Execute_globalPC;
TLaddressint	Language_Execute_globalSP;
typedef	Language_Opcode	Language_Execute___x1661[1];
Language_Execute___x1661	Language_Execute_nullRoutine = 
    {206};

void Language_Execute_RunSrcPosition (srcPos)
struct SrcPosition	*srcPos;
{
    TLSTKCHKSLF(100248);
    TLSETF();
    TLSETL(100248);
    if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	TLSETL(100249);
	TLSTRCTASS((*srcPos), Language_nullSrcPosition, struct SrcPosition);
    } else {
	TLSETL(100251);
	TLSTRCTASS((*srcPos), Language_Execute_RQHead->srcPos, struct SrcPosition);
    };
    TLRESTORELF();
}

void Language_Execute_SetErrno (errno, errMessage)
TLint4	errno;
TLaddressint	errMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100260);
    TLSETF();
    TLSETL(100260);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(100262);
    (*pd).prevErrno = (*pd).errno;
    TLINCL();
    TLSTRASS(255, (*pd).prevErrMessage, (*pd).errMessage);
    TLINCL();
    (*pd).errno = errno;
    TLINCL();
    if ((unsigned long) errMessage == 0) {
	TLSETL(100266);
	TLSTRASS(255, (*pd).errMessage, "");
    } else {
	TLSETL(100268);
	TLSTRASS(255, (*pd).errMessage, (* (TLstring *) errMessage));
    };
    TLRESTORELF();
}

void Language_Execute_GetErrno (errno, prevErrno, errMessage, prevErrMessage)
TLint4	*errno;
TLint4	*prevErrno;
TLaddressint	*errMessage;
TLaddressint	*prevErrMessage;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    TLSTKCHKSLF(100278);
    TLSETF();
    TLSETL(100278);
    pd = &((*(Language_Execute_RQHead)));
    TLINCL();
    (*errno) = (*pd).errno;
    TLINCL();
    (*errMessage) = (TLaddressint) ((unsigned long)(*pd).errMessage);
    TLINCL();
    (*prevErrno) = (*pd).prevErrno;
    TLINCL();
    (*prevErrMessage) = (TLaddressint) ((unsigned long)(*pd).prevErrMessage);
    TLRESTORELF();
}

static void Language_Execute_OpenFile (openMode, fileName, streamNo)
TLint2	openMode;
TLstring	fileName;
TLint4	*streamNo;
{
    TLstring	fullName;
    TLSTKCHKSLF(100289);
    TLSETF();
    TLSETL(100289);
    {
	TLchar	__x1665[6];
	{
	    TLchar	__x1664[10];
	    {
		TLchar	__x1663[9];
		if ((((TL_TLS_TLSLEN(fileName) >= 7) && ((TL_TLS_TLSBXX(__x1663, (TLint4) 7, (TLint4) 1, fileName), strcmp(__x1663, "%window") == 0))) || ((TL_TLS_TLSLEN(fileName) >= 8) && ((TL_TLS_TLSBXX(__x1664, (TLint4) 8, (TLint4) 1, fileName), strcmp(__x1664, "%printer") == 0)))) || ((TL_TLS_TLSLEN(fileName) >= 4) && ((TL_TLS_TLSBXX(__x1665, (TLint4) 4, (TLint4) 1, fileName), strcmp(__x1665, "%net") == 0)))) {
		    TLSETL(100292);
		    TLSTRASS(255, fullName, fileName);
		} else {
		    TLSETL(100294);
		    {
			TLstring	__x1666;
			FileManager_ExecPathName(fileName, __x1666);
			TLSTRASS(255, fullName, __x1666);
		    };
		};
	    };
	};
    };
    TLSETL(100301);
    TL_TLI_TLIOF((TLint2) openMode, fullName, &((*streamNo)));
    TLRESTORELF();
}

TLint4 Language_Execute_GetStackAllocated () {
    TLSTKCHKSLF(100305);
    TLSETF();
    TLSETL(100305);
    TLRESTORELF();
    return (Language_Execute_stackAllocated);
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}
static TLint4	Language_Execute_failedOpenStream;
struct	Language_Execute___x1668 {
    TLint4	streamNo;
    TLstring	msg;
    struct SrcPosition	srcPos;
};
typedef	struct Language_Execute___x1668	Language_Execute___x1667[10];
static Language_Execute___x1667	Language_Execute_failedOpenInfo;

void Language_Execute_AddFile (fnum, mode)
TLint4	*fnum;
TLint4	mode;
{
    TLSTKCHKSLF(100318);
    TLSETF();
    TLSETL(100318);
    if ((*fnum) == 0) {
	TLint4	arrayPos;
	TLint4	errno;
	TLint4	prevErrno;
	TLaddressint	errMsg;
	TLaddressint	prevErrMsg;
	TLSETL(100327);
	(*fnum) = Language_Execute_failedOpenStream;
	TLINCL();
	Language_Execute_failedOpenStream -= 1;
	TLINCL();
	arrayPos = (( TLSIMPLEABS((*fnum))) % 10) + 1;
	TLINCL();
	Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].streamNo = (*fnum);
	TLSETL(100334);
	Language_Execute_GetErrno(&(errno), &(prevErrno), &(errMsg), &(prevErrMsg));
	TLINCL();
	strcpy(Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].msg, (* (TLstring *) errMsg));
	TLSETL(100337);
	Language_Execute_RunSrcPosition(&(Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos));
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(100340);
    if ((Language_Execute_numArguments + Language_Execute_numFilesOpen) == 20) {
	TLSETL(100341);
	TL_TLI_TLICL ((TLint4) (*fnum));
	TLINCL();
	(*fnum) = 0;
	TLSETL(100344);
	TLRESTORELF();
	return;
    };
    TLSETL(100346);
    {
	register TLint4	i;
	for (i = Language_Execute_numArguments + 1; i <= 20; i++) {
	    TLSETL(100347);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) == -3) {
		TLSETL(100348);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = (*fnum);
		TLINCL();
		(*fnum) = i;
		TLINCL();
		Language_Execute_numFilesOpen += 1;
		TLSETL(100355);
		MIO_RegisterOpen((TLint4) (*fnum), (TLint4) mode);
		TLINCL();
		TLRESTORELF();
		return;
	    };
	};
    };
    TLSETL(100358);
    TLASSERT (0);
    TLRESTORELF();
}

static void Language_Execute_BadStreamAbortMessage (streamNumber, op)
TLint4	streamNumber;
TLstring	op;
{
    TLint4	arrayPos;
    struct SrcPosition	srcPos;
    TLint4	failedOpenLineNo;
    TLint4	failedOpenFileNo;
    TLstring	failedOpenMsg;
    TLSTKCHKSLF(100365);
    TLSETF();
    TLSETL(100365);
    if ((streamNumber <= Language_Execute_failedOpenStream) || (((- 10) < streamNumber) && (streamNumber < (- 2)))) {
	TLSETL(100372);
	{
	    TLstring	__x1672;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1672);
	    {
		TLstring	__x1671;
		TL_TLS_TLSCAT(op, " attempted on illegal stream number ", __x1671);
		{
		    TLstring	__x1670;
		    TL_TLS_TLSCAT(__x1671, __x1672, __x1670);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1670);
		};
	    };
	};
    };
    TLSETL(100377);
    arrayPos = (( TLSIMPLEABS(streamNumber)) % 10) + 1;
    TLINCL();
    if (TL_TLI_TLIXSN != (Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].streamNo)) {
	TLSETL(100387);
	{
	    TLstring	__x1676;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1676);
	    {
		TLstring	__x1675;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1675);
		{
		    TLstring	__x1674;
		    TL_TLS_TLSCAT(__x1675, __x1676, __x1674);
		    {
			TLstring	__x1673;
			TL_TLS_TLSCAT(__x1674, ". Previous open statement failed", __x1673);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1673);
		    };
		};
	    };
	};
    };
    TLSETL(100392);
    failedOpenLineNo = Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos.lineNo;
    TLSETL(100394);
    failedOpenFileNo = Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].srcPos.fileNo;
    TLSETL(100396);
    TLSTRASS(255, failedOpenMsg, Language_Execute_failedOpenInfo[TLINRANGELOW(arrayPos, 1, 10, 1)].msg);
    TLSETL(100399);
    Language_Execute_RunSrcPosition(&(srcPos));
    if ((srcPos.fileNo) != failedOpenFileNo) {
	TLSETL(100409);
	{
	    TLstring	__x1688;
	    FileManager_FileName((FileManager_FileNoType) failedOpenFileNo, __x1688);
	    {
		TLstring	__x1687;
		TL_TLS_TLSVIS((TLint4) failedOpenLineNo, (TLint4) 1, (TLint4) 10, __x1687);
		{
		    TLstring	__x1686;
		    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1686);
		    {
			TLstring	__x1685;
			TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1685);
			{
			    TLstring	__x1684;
			    TL_TLS_TLSCAT(__x1685, __x1686, __x1684);
			    {
				TLstring	__x1683;
				TL_TLS_TLSCAT(__x1684, ". Open on line ", __x1683);
				{
				    TLstring	__x1682;
				    TL_TLS_TLSCAT(__x1683, __x1687, __x1682);
				    {
					TLstring	__x1681;
					TL_TLS_TLSCAT(__x1682, " of ", __x1681);
					{
					    TLstring	__x1680;
					    TL_TLS_TLSCAT(__x1681, __x1688, __x1680);
					    {
						TLstring	__x1679;
						TL_TLS_TLSCAT(__x1680, "failed with message \'", __x1679);
						{
						    TLstring	__x1678;
						    TL_TLS_TLSCAT(__x1679, failedOpenMsg, __x1678);
						    {
							TLstring	__x1677;
							TL_TLS_TLSCAT(__x1678, "\'", __x1677);
							Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1677);
						    };
						};
					    };
					};
				    };
				};
			    };
			};
		    };
		};
	    };
	};
    };
    TLSETL(100413);
    if ((((srcPos.lineNo) - failedOpenLineNo) <= 3) && ((srcPos.lineNo) >= failedOpenLineNo)) {
	TLSETL(100422);
	{
	    TLstring	__x1694;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1694);
	    {
		TLstring	__x1693;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1693);
		{
		    TLstring	__x1692;
		    TL_TLS_TLSCAT(__x1693, __x1694, __x1692);
		    {
			TLstring	__x1691;
			TL_TLS_TLSCAT(__x1692, ". Open failed with message \'", __x1691);
			{
			    TLstring	__x1690;
			    TL_TLS_TLSCAT(__x1691, failedOpenMsg, __x1690);
			    {
				TLstring	__x1689;
				TL_TLS_TLSCAT(__x1690, "\'", __x1689);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1689);
			    };
			};
		    };
		};
	    };
	};
    };
    TLSETL(100437);
    {
	TLstring	__x1703;
	TL_TLS_TLSVIS((TLint4) failedOpenLineNo, (TLint4) 1, (TLint4) 10, __x1703);
	{
	    TLstring	__x1702;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1702);
	    {
		TLstring	__x1701;
		TL_TLS_TLSCAT(op, " attempted on unopened stream number ", __x1701);
		{
		    TLstring	__x1700;
		    TL_TLS_TLSCAT(__x1701, __x1702, __x1700);
		    {
			TLstring	__x1699;
			TL_TLS_TLSCAT(__x1700, ". Open on line ", __x1699);
			{
			    TLstring	__x1698;
			    TL_TLS_TLSCAT(__x1699, __x1703, __x1698);
			    {
				TLstring	__x1697;
				TL_TLS_TLSCAT(__x1698, " failed with message \'", __x1697);
				{
				    TLstring	__x1696;
				    TL_TLS_TLSCAT(__x1697, failedOpenMsg, __x1696);
				    {
					TLstring	__x1695;
					TL_TLS_TLSCAT(__x1696, "\'", __x1695);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1695);
				    };
				};
			    };
			};
		    };
		};
	    };
	};
    };
    TLRESTORELF();
}

static void Language_Execute_CloseArguments () {
    TLSTKCHKSLF(100441);
    TLSETF();
    TLSETL(100441);
    {
	register TLint4	i;
	TLint4	__x1704;
	__x1704 = Language_Execute_numArguments;
	i = 1;
	if (i <= __x1704) {
	    for(;;) {
		TLSETL(100442);
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) != ((Language_StringDef *) 0)) {
		    TLSETL(100443);
		    TL_TLB_TLBFRU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		    Language_StringDef));
		    TLINCL();
		    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
		};
		if (i == __x1704) break;
		i++;
	    }
	};
    };
    TLSETL(100447);
    Language_Execute_numArguments = 0;
    TLRESTORELF();
}

void Language_Execute_CloseFile (fnum)
register TLint4	fnum;
{
    TLSTKCHKSLF(100452);
    TLSETF();
    TLSETL(100452);
    TL_TLI_TLIXSN = fnum;
    TLINCL();
    if (fnum < (- 2)) {
	TLSETL(100455);
	Language_Execute_BadStreamAbortMessage((TLint4) fnum, "Close");
    } else {
	TLSETL(100455);
	if (fnum > 20) {
	    TLSETL(100458);
	    {
		TLstring	__x1706;
		TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x1706);
		{
		    TLstring	__x1705;
		    TL_TLS_TLSCAT("Close of illegal stream number ", __x1706, __x1705);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1705);
		};
	    };
	} else {
	    TLSETL(100458);
	    if ((Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]) == -3) {
		TLSETL(100461);
		{
		    TLstring	__x1708;
		    TL_TLS_TLSVIS((TLint4) fnum, (TLint4) 1, (TLint4) 10, __x1708);
		    {
			TLstring	__x1707;
			TL_TLS_TLSCAT("Close of closed stream number ", __x1708, __x1707);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1707);
		    };
		};
	    };
	};
    };
    TLSETL(100463);
    TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)]));
    TLSETL(100468);
    MIO_RegisterClose((TLint4) fnum);
    Language_Execute_fileMap[TLINRANGELOW(fnum, -2, 20, 1)] = -3;
    TLSETL(100470);
    if (fnum > Language_Execute_numArguments) {
	TLSETL(100471);
	Language_Execute_numFilesOpen -= 1;
    };
    TLRESTORELF();
}

static void Language_Execute_CloseAllFiles () {
    TLSTKCHKSLF(100477);
    TLSETF();
    TLSETL(100477);
    if ((Language_Execute_fileMap[0]) != -2) {
	TLSETL(100478);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[0]));
	TLINCL();
	Language_Execute_fileMap[0] = -2;
    };
    TLSETL(100481);
    if ((Language_Execute_fileMap[1]) != -1) {
	TLSETL(100482);
	TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[1]));
	TLINCL();
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    };
    TLSETL(100486);
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100487);
	    if ((Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]) != -3) {
		TLSETL(100488);
		TL_TLI_TLICL ((TLint4) (Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)]));
		TLSETL(100493);
		MIO_RegisterClose((TLint4) i);
		Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    };
	};
    };
    TLSETL(100496);
    Language_Execute_numFilesOpen = 0;
    TLRESTORELF();
}

static void Language_Execute_OpenArgumentFile (mode, abort)
Language_StreamModeSet	mode;
TLboolean	abort;
{
    TLint4	f;
    TLSTKCHKSLF(100501);
    TLSETF();
    TLSETL(100501);
    TLPRE (((TL_TLI_TLIXSN > 0) && (TL_TLI_TLIXSN <= Language_Execute_numArguments)) && ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3));
    TLSETL(100505);
    if ((Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
	TLSETL(100508);
	{
	    TLstring	__x1711;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1711);
	    {
		TLstring	__x1710;
		TL_TLS_TLSCAT("Open argument ", __x1711, __x1710);
		{
		    TLstring	__x1709;
		    TL_TLS_TLSCAT(__x1710, " does not exist", __x1709);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1709);
		};
	    };
	};
    };
    TLSETL(100513);
    Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &mode), (*(Language_Execute_argumentNames[TLINRANGELOW(TL_TLI_TLIXSN, 0, 20, 1)])), &(f));
    if (f == 0) {
	TLSETL(100514);
	if (abort) {
	    TLSETL(100518);
	    {
		TLstring	__x1713;
		TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1713);
		{
		    TLstring	__x1712;
		    TL_TLS_TLSCAT("Cannot open argument file number ", __x1713, __x1712);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1712);
		};
	    };
	} else {
	    TLSETL(100519);
	    TL_TLI_TLIXSN = 0;
	};
    } else {
	TLSETL(100522);
	Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)] = f;
    };
    TLRESTORELF();
}

void Language_Execute_SetActive (stream)
TLint4	*stream;
{
    TLint4	fd;
    TLSTKCHKSLF(100530);
    TLSETF();
    TLSETL(100530);
    fd = -1;
    TLINCL();
    if ((*stream) != 0) {
	TLSETL(100532);
	if ((Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)]) != -3) {
	    TLSETL(100533);
	    fd = Language_Execute_fileMap[TLINRANGELOW((*stream), -2, 20, 1)];
	} else {
	    TLSETL(100535);
	    (*stream) = 0;
	};
    };
    TLSETL(100538);
    if (MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) fd))) {
	TLboolean	dummy;
	TLSETL(100540);
	dummy = MIO_SetActive((TLaddressint) TL_TLI_TLIGF((TLint4) -1));
    };
    TLRESTORELF();
}

extern TLboolean Language_Execute_Kernel_ConditionEmpty ();

extern TLnat4 Language_Execute_Kernel_GetProcessPriority ();

extern void Language_Execute_Kernel_Initialize ();

extern void Language_Execute_Kernel_InitializeCondition ();

extern void Language_Execute_Kernel_MonitorEnter ();

extern void Language_Execute_Kernel_MonitorExit ();

extern void Language_Execute_Kernel_MonitorFree ();

extern void Language_Execute_Kernel_MonitorInitialize ();

extern void Language_Execute_Kernel_Pause ();

extern void Language_Execute_Kernel_RunQueueDispatch ();

extern void Language_Execute_Kernel_RunQueueInsert ();

extern void Language_Execute_Kernel_SetProcessPriority ();

extern void Language_Execute_Kernel_SignalDeferredCondition ();

extern void Language_Execute_Kernel_SignalPriorityCondition ();

extern void Language_Execute_Kernel_SignalRegularCondition ();

extern void Language_Execute_Kernel_SignalTimeoutCondition ();

extern void Language_Execute_Kernel_TimeSlice ();

extern void Language_Execute_Kernel_WaitDeferredCondition ();

extern void Language_Execute_Kernel_WaitPriorityCondition ();

extern void Language_Execute_Kernel_WaitRegularCondition ();

extern void Language_Execute_Kernel_WaitTimeoutCondition ();

TLboolean Language_Execute_HasEvent (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    TLint4	fileStream;
    TLSTKCHKSLF(100629);
    TLSETF();
    TLSETL(100629);
    fileStream = Language_Execute_fileMap[TLINRANGELOW(stream, -2, 20, 1)];
    TLINCL();
    if (fileStream == -3) {
	TLSETL(100632);
	TLRESTORELF();
	return (1);
    } else {
	TLSETL(100634);
	TLRESTORELF();
	return (MIO_HasEvent((TLaddressint) TL_TLI_TLIGF((TLint4) fileStream), &((*event))));
    };
    TLRESTORELF();
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_EventQueueInsert (stream, event)
TLint4	stream;
struct MIO_EventDescriptor	*event;
{
    register struct Language_Execute_ProcessDescriptor	*pd;
    TLSTKCHKSLF(100642);
    TLSETF();
    TLSETL(100642);
    pd = Language_Execute_RQHead;
    TLINCL();
    pd->pendingEvent.stream = stream;
    TLINCL();
    TLSTRCTASS(pd->pendingEvent.event, (*event), struct MIO_EventDescriptor);
    TLINCL();
    Language_Execute_RQHead = pd->nextProcess;
    TLINCL();
    pd->nextProcess = Language_Execute_EQHead;
    TLINCL();
    Language_Execute_EQHead = pd;
    TLSETL(100649);
    Language_Execute_Kernel_RunQueueDispatch();
    TLRESTORELF();
}

static void Language_Execute_EventQueueDispatch () {
    struct Language_Execute_ProcessDescriptor	*pd;
    struct Language_Execute_ProcessDescriptor	*lastPD;
    TLSTKCHKSLF(100653);
    TLSETF();
    TLSETL(100653);
    pd = Language_Execute_EQHead;
    TLINCL();
    lastPD = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_allWaitingForKeyboard = 1;
    TLINCL();
    Language_Execute_allWaitingForMouse = 1;
    TLINCL();
    Language_Execute_allWaitingForDelay = 1;
    TLINCL();
    Language_Execute_minimumDelayCount = 2000000000;
    TLSETL(100660);
    for(;;) {
	TLSETL(100660);
	if (pd == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    break;
	};
	TLSETL(100661);
	if (Language_Execute_HasEvent((TLint4) (pd->pendingEvent.stream), &(pd->pendingEvent.event))) {
	    TLSETL(100663);
	    if (lastPD == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(100664);
		Language_Execute_EQHead = pd->nextProcess;
		TLSETL(100666);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = Language_Execute_EQHead;
	    } else {
		TLSETL(100668);
		lastPD->nextProcess = pd->nextProcess;
		TLSETL(100670);
		Language_Execute_Kernel_RunQueueInsert(pd);
		pd = lastPD->nextProcess;
	    };
	} else {
	    TLnat1	mode;
	    TLSETL(100673);
	    mode = pd->pendingEvent.event.mode;
	    TLSETL(100676);
	    if ((((mode != 0) && (mode != 1)) && (mode != 2)) && (mode != 3)) {
		TLSETL(100680);
		Language_Execute_allWaitingForKeyboard = 0;
		TLINCL();
		if (mode != 6) {
		    TLSETL(100682);
		    Language_Execute_allWaitingForMouse = 0;
		    TLINCL();
		    if (((mode != 5) && (mode != 7)) && (mode != 8)) {
			TLSETL(100686);
			Language_Execute_allWaitingForDelay = 0;
		    } else {
			TLSETL(100688);
			if (mode == 99) {
			    TLSETL(100690);
			    Language_Execute_minimumDelayCount =  TL_TLA_TLAIMN((TLint4) Language_Execute_minimumDelayCount, (TLint4) ((* (TLint4 *) (pd->pendingEvent.event.count))));
			} else {
			    TLSETL(100693);
			    Language_Execute_minimumDelayCount =  TLSIMPLEMIN(Language_Execute_minimumDelayCount, (pd->pendingEvent.event.count));
			};
		    };
		};
	    };
	    TLSETL(100694);
	    lastPD = pd;
	    TLINCL();
	    pd = pd->nextProcess;
	};
    };
    TLRESTORELF();
}

TLboolean Language_Execute_Strintok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1388;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100702);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100702);
	{
	    __x1388 = 0;
	    TLRESTORELF();
	    return (__x1388);
	};
    } else {
	TLint4	dummy;
	TLSETF();
	TLSETL(100706);
	dummy = TL_TLS_TLSVSI(str, (TLint4) base);
	TLINCL();
	{
	    __x1388 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1388);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

TLboolean Language_Execute_Strnatok (str, base)
TLstring	str;
TLint4	base;
{
    TLboolean	__x1393;
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100713);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100713);
	{
	    __x1393 = 0;
	    TLRESTORELF();
	    return (__x1393);
	};
    } else {
	TLnat4	dummy;
	TLSETF();
	TLSETL(100717);
	dummy = TL_TLS_TLSVSN(str, (TLint4) base);
	TLINCL();
	{
	    __x1393 = 1;
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return (__x1393);
	};
	TL_TLE_TLEHX();
    }
    /* NOTREACHED */
    TLFCNRESULTABORT;
}

void Language_Execute_Open () {
    Language_OpenKind	oKind;
    Language_StreamModeSet	oMode;
    TLSTKCHKSLF(100723);
    TLSETF();
    TLSETL(100723);
    TLASSERT (sizeof(Language_OpenKind) == 1);
    TLINCL();
    oKind = (* (Language_OpenKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLINCL();
    TLASSERT (sizeof(Language_StreamModeSet) == 1);
    TLINCL();
    oMode = (* (Language_StreamModeSet *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100734);
    switch (oKind) {
	case 0:
	    {
		TLSETL(100738);
		TL_TLI_TLIOP (((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP)))), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))));
		TLSETL(100742);
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))))), (TLint4) 0);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 1:
	    {
		TLSETL(100749);
		Language_Execute_OpenFile((TLint2) (* (TLnat1 *) &oMode), (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))));
		TLINCL();
		Language_Execute_AddFile(&((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) (* (TLnat1 *) &oMode));
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100754);
		TL_TLI_TLIXSN = (* (TLint4 *) Language_Execute_globalSP);
		TLINCL();
		if ((TL_TLI_TLIXSN <= 0) || (TL_TLI_TLIXSN > Language_Execute_numArguments)) {
		    TLSETL(100759);
		    {
			TLstring	__x1733;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1733);
			{
			    TLstring	__x1732;
			    TL_TLS_TLSCAT("Open argument ", __x1733, __x1732);
			    {
				TLstring	__x1731;
				TL_TLS_TLSCAT(__x1732, " does not exist", __x1731);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1731);
			    };
			};
		    };
		};
		TLSETL(100760);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) != -3) {
		    TLSETL(100763);
		    {
			TLstring	__x1736;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1736);
			{
			    TLstring	__x1735;
			    TL_TLS_TLSCAT("Open argument ", __x1736, __x1735);
			    {
				TLstring	__x1734;
				TL_TLS_TLSCAT(__x1735, " is already open", __x1734);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1734);
			    };
			};
		    };
		};
		TLSETL(100765);
		Language_Execute_OpenArgumentFile((Language_StreamModeSet) oMode, (TLboolean) 0);
		(* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4)))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_Put () {
    Language_PutKind	pKind;
    TLint4	stream;
    TLSTKCHKSLF(100772);
    TLSETF();
    TLSETL(100772);
    TLASSERT (sizeof(Language_PutKind) == 1);
    TLINCL();
    pKind = (* (Language_PutKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100776);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100783);
	{
	    TLstring	__x1743;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1743);
	    {
		TLstring	__x1742;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x1743, __x1742);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1742);
	    };
	};
    };
    TLSETL(100785);
    switch (pKind) {
	case 0:
	    {
		TLSETL(100787);
		if (((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))) != 0) {
		    TLSETL(100788);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "true", (TLint2) stream);
		} else {
		    TLSETL(100790);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), "false", (TLint2) stream);
		};
		TLSETL(100792);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 1:
	    {
		TLSETL(100795);
		{
		    TLchar	__x1748[1];
		    TLCHRTOCHARS(((TLchar) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)))), __x1748);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPC ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), __x1748, (TLint4) 1, (TLint2) stream);
		};
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 2:
	    {
		TLSETL(100805);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 2);
		TLSETL(100808);
		TL_TLI_TLIPC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 3:
	    {
		TLint4	value;
		register TLaddressint	ptr;
		TLSETL(100812);
		value = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
		TLINCL();
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		if ((value >= 0) && (value < ((* (TLint4 *) ptr)))) {
		    TLSETL(100815);
		    ptr += 4;
		    TLINCL();
		    {
			register TLint4	__x1402;
			TLint4	__x1756;
			__x1756 = value;
			__x1402 = 1;
			if (__x1402 <= __x1756) {
			    for(;;) {
				TLSETL(100818);
				for(;;) {
				    TLSETL(100818);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) == '\0') {
					break;
				    };
				};
				TLSETL(100822);
				for(;;) {
				    TLSETL(100822);
				    ptr += 1;
				    TLINCL();
				    if (((* (TLchar *) ptr)) != '\0') {
					break;
				    };
				};
				if (__x1402 == __x1756) break;
				__x1402++;
			    }
			};
		    };
		    TLSETL(100826);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((* (TLstring *) ptr)), (TLint2) stream);
		} else {
		    TLSETL(100828);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		    TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) value, (TLint2) stream);
		};
		TLSETL(100830);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 4:
	    {
		TLSETL(100833);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPI ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 5:
	    {
		TLSETL(100837);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4))))), (TLint2) stream);
		TLSETL(100839);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 6:
	    {
		TLSETL(100842);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), ((TLreal8) (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4))))), (TLint2) stream);
		TLSETL(100845);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 7:
	    {
		TLSETL(100848);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 8:
	    {
		TLSETL(100852);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100854);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 9:
	    {
		TLSETL(100857);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPN ((TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLnat4) ((* (TLnat4 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100860);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 10:
	    {
		TLSETL(100863);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPR ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 11:
	    {
		TLSETL(100867);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPF ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		TLSETL(100869);
		Language_Execute_globalSP += 16;
	    }
	    break;
	case 12:
	    {
		TLSETL(100872);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPE ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLreal8) ((* (TLreal8 *) ((unsigned long) Language_Execute_globalSP + (3 * 4)))), (TLint2) stream);
		TLSETL(100875);
		Language_Execute_globalSP += 20;
	    }
	    break;
	case 13:
	    {
		TLSETL(100878);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), ((* (TLstring *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint2) stream);
		TLSETL(100880);
		Language_Execute_globalSP += 8;
	    }
	    break;
	case 14:
	    {
		TLSETL(100883);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "", (TLint2) stream);
		TL_TLI_TLIPK ((TLint2) stream);
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLSETL(100886);
    Language_Execute_executionTimeout -= 500;
    TLRESTORELF();
}

void Language_Execute_Get () {
    TLaddressint	startPC;
    TLaddressint	startSP;
    Language_GetKind	gKind;
    Language_Offset	sz;
    TLint4	stream;
    struct MIO_EventDescriptor	event;
    TLSTKCHKSLF(100891);
    TLSETF();
    TLSETL(100891);
    startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
    TLINCL();
    startSP = (TLaddressint) Language_Execute_globalSP;
    TLSETL(100894);
    TLASSERT (sizeof(Language_GetKind) == 1);
    TLINCL();
    gKind = (* (Language_GetKind *) Language_Execute_globalPC);
    TLINCL();
    Language_Execute_globalPC += Language_codeInt1Size;
    TLSETL(100899);
    if (gKind == 13) {
	TLSETL(100900);
	sz = 0;
    } else {
	TLSETL(100902);
	TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
	TLINCL();
	sz = (* (Language_Offset *) Language_Execute_globalPC);
	TLINCL();
	Language_Execute_globalPC += Language_codeOffsetSize;
    };
    TLSETL(100907);
    TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
    TLINCL();
    Language_Execute_globalSP += 4;
    TLINCL();
    stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
    TLINCL();
    if (stream == -3) {
	TLSETL(100914);
	{
	    TLstring	__x1797;
	    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1797);
	    {
		TLstring	__x1796;
		TL_TLS_TLSCAT("I/O attempted on closed stream ", __x1797, __x1796);
		Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1796);
	    };
	};
    };
    TLSETL(100917);
    switch (gKind) {
	case 1:
	case 2:
	    {
		TLSETL(100919);
		event.mode = 2;
		TLINCL();
		event.count = 1;
	    }
	    break;
	case 3:
	    {
		TLint4	width;
		TLSETL(100922);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100926);
		    {
			TLstring	__x1801;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x1801);
			{
			    TLstring	__x1800;
			    TL_TLS_TLSCAT("Negative get width of ", __x1801, __x1800);
			    {
				TLstring	__x1799;
				TL_TLS_TLSCAT(__x1800, " specified", __x1799);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1799);
			    };
			};
		    };
		};
		TLSETL(100927);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100932);
		    {
			TLstring	__x1808;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x1808);
			{
			    TLstring	__x1806;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x1806);
			    {
				TLstring	__x1805;
				TL_TLS_TLSCAT("Get width of ", __x1806, __x1805);
				{
				    TLstring	__x1804;
				    TL_TLS_TLSCAT(__x1805, " is longer than char string variable size of ", __x1804);
				    {
					TLstring	__x1803;
					TL_TLS_TLSCAT(__x1804, __x1808, __x1803);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1803);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100933);
		event.mode = 2;
		TLINCL();
		event.count = width;
	    }
	    break;
	case 11:
	    {
		TLSETL(100936);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	case 10:
	    {
		TLint4	width;
		TLSETL(100939);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		if (width < 0) {
		    TLSETL(100943);
		    {
			TLstring	__x1812;
			TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x1812);
			{
			    TLstring	__x1811;
			    TL_TLS_TLSCAT("Negative get width of ", __x1812, __x1811);
			    {
				TLstring	__x1810;
				TL_TLS_TLSCAT(__x1811, " specified", __x1810);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1810);
			    };
			};
		    };
		};
		TLSETL(100944);
		if (width > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(100949);
		    {
			TLstring	__x1819;
			TL_TLS_TLSVIS((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLint4) 1, (TLint4) 10, __x1819);
			{
			    TLstring	__x1817;
			    TL_TLS_TLSVIS((TLint4) width, (TLint4) 1, (TLint4) 10, __x1817);
			    {
				TLstring	__x1816;
				TL_TLS_TLSCAT("Get width of ", __x1817, __x1816);
				{
				    TLstring	__x1815;
				    TL_TLS_TLSCAT(__x1816, " is longer than string variable size of ", __x1815);
				    {
					TLstring	__x1814;
					TL_TLS_TLSCAT(__x1815, __x1819, __x1814);
					Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1814);
				    };
				};
			    };
			};
		    };
		};
		TLSETL(100950);
		event.mode = 1;
		TLINCL();
		event.count = 0;
	    }
	    break;
	default :
	    {
		TLSETL(100953);
		event.mode = 0;
		TLINCL();
		event.count = 0;
	    }
	    break;
    };
    TLSETL(100957);
    if (!Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
	TLSETL(100958);
	Language_Execute_globalPC = (TLaddressint) startPC;
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) startSP;
	TLSETL(100961);
	Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
	TLINCL();
	TLRESTORELF();
	return;
    };
    TLSETL(100964);
    switch (gKind) {
	case 0:
	    {
		TLstring	tstring;
		TLSETL(100967);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (strcmp(tstring, "true") == 0) {
		    TLSETL(100969);
		    (* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 1;
		} else {
		    TLSETL(100970);
		    if (strcmp(tstring, "false") == 0) {
			TLSETL(100971);
			(* (TLboolean *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		    } else {
			TLSETL(100975);
			{
			    TLstring	__x1825;
			    TL_TLS_TLSCAT("Value of \'", tstring, __x1825);
			    {
				TLstring	__x1824;
				TL_TLS_TLSCAT(__x1825, "\' is invalid for boolean input", __x1824);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1824);
			    };
			};
		    };
		};
	    }
	    break;
	case 1:
	    {
		TLSETL(100978);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), &((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 3:
	    {
		TLSETL(100988);
		TL_TLI_TLISS((TLint4) stream, (TLint2) 1);
		TLSETL(100991);
		TL_TLI_TLIGC((TLint4) ((* (TLint4 *) Language_Execute_globalSP)), (TLaddressint) ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4))), (TLint4) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4)))), (TLint2) stream);
		Language_Execute_globalSP += 12;
	    }
	    break;
	case 2:
	    {
		TLchar	c;
		TLSETL(100995);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGC ((TLint4) sizeof c, &c, (TLint4) sizeof c, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if (((* (TLnat1 *) &c) < ((* (TLint4 *) Language_Execute_globalPC))) || ((* (TLnat1 *) &c) > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(100999);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(101000);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		(* (TLchar *) ((* (TLaddressint *) Language_Execute_globalSP))) = c;
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 4:
	    {
		TLstring	tstring;
		register TLaddressint	ptr;
		TLint4	count;
		TLSETL(101006);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLSETL(101008);
		ptr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(101011);
		count = (* (TLint4 *) ptr);
		TLINCL();
		ptr += 4;
		TLSETL(101014);
		{
		    register TLint4	i;
		    TLint4	__x1837;
		    __x1837 = count - 1;
		    i = 0;
		    if (i <= __x1837) {
			for(;;) {
			    TLSETL(101016);
			    for(;;) {
				TLSETL(101016);
				if (((* (TLchar *) ptr)) != '\0') {
				    break;
				};
				TLSETL(101017);
				ptr += 1;
			    };
			    TLSETL(101019);
			    if (strcmp(tstring, (* (TLstring *) ptr)) == 0) {
				TLSETL(101020);
				switch (sz) {
				    case 1:
					{
					    TLSETL(101022);
					    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 2:
					{
					    TLSETL(101024);
					    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    case 4:
					{
					    TLSETL(101026);
					    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
					}
					break;
				    default:
					TLCASEABORT;
				};
				TLSETL(101029);
				break;
			    };
			    TLSETL(101031);
			    for(;;) {
				TLSETL(101031);
				ptr += 1;
				TLINCL();
				if (((* (TLchar *) ptr)) == '\0') {
				    break;
				};
			    };
			    if (i == __x1837) break;
			    i++;
			}
		    };
		};
		TLSETL(101035);
		if (((* (TLchar *) ptr)) == '\0') {
		    TLSETL(101038);
		    {
			TLstring	__x1849;
			TL_TLS_TLSCAT("Value of \'", tstring, __x1849);
			{
			    TLstring	__x1848;
			    TL_TLS_TLSCAT(__x1849, "\' is not a valid enum member", __x1848);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1848);
			};
		    };
		};
		TLSETL(101039);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 6:
	    {
		TLSETL(101042);
		switch (sz) {
		    case 1:
			{
			    TLSETL(101044);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(101046);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(101048);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGI (&((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101050);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 8:
	    {
		TLSETL(101053);
		switch (sz) {
		    case 1:
			{
			    TLSETL(101055);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat1 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 2:
			{
			    TLSETL(101057);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat2 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    case 4:
			{
			    TLSETL(101059);
			    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
			    TL_TLI_TLIGN (&((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLnat4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101061);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 9:
	    {
		TLSETL(101064);
		if (sz == 8) {
		    TLSETL(101065);
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal8 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		} else {
		    TLSETL(101067);
		    TLASSERT (sz == 4);
		    TLINCL();
		    TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		    TL_TLI_TLIGR (&((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint4) sizeof ((* (TLreal4 *) ((* (TLaddressint *) Language_Execute_globalSP)))), (TLint2) stream);
		};
		TLSETL(101070);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 13:
	    {
		TLSETL(101073);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGK ((TLint2) stream);
	    }
	    break;
	case 11:
	    {
		TLstring	tstring;
		TLSETL(101077);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSS((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(101081);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(101082);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101085);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 10:
	    {
		register TLint4	width;
		TLSETL(101088);
		width = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLINCL();
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGSW ((TLint4) 255, (TLint4) width, (* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), (TLint2) stream);
		TLINCL();
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 12:
	    {
		TLstring	tstring;
		TLSETL(101096);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGS ((TLint4) 255, tstring, (TLint2) stream);
		TLINCL();
		if (TL_TLS_TLSLEN(tstring) > ((* (TLint4 *) Language_Execute_globalSP))) {
		    TLSETL(101100);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input string is too large for string variable");
		};
		TLSETL(101101);
		Language_Execute_globalSP += 4;
		TLINCL();
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101104);
		strcpy((* (TLstring *) ((* (TLaddressint *) Language_Execute_globalSP))), tstring);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 7:
	    {
		TLint4	i;
		TLSETL(101108);
		TL_TLI_TLISS ((TLint4) stream, (TLint2) 1);
		TL_TLI_TLIGI (&i, (TLint4) sizeof i, (TLint2) stream);
		TLINCL();
		TLASSERT (((unsigned long) Language_Execute_globalPC & (3)) == 0);
		TLINCL();
		if ((i < ((* (TLint4 *) Language_Execute_globalPC))) || (i > ((* (TLint4 *) ((unsigned long) Language_Execute_globalPC + Language_codeIntSize))))) {
		    TLSETL(101113);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Input value is out of range");
		};
		TLSETL(101114);
		Language_Execute_globalPC += 2 * Language_codeIntSize;
		TLINCL();
		switch (sz) {
		    case 1:
			{
			    TLSETL(101117);
			    (* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 2:
			{
			    TLSETL(101119);
			    (* (TLint2 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    case 4:
			{
			    TLSETL(101121);
			    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = i;
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101123);
		Language_Execute_globalSP += 4;
	    }
	    break;
	default:
	    TLCASEABORT;
    };
    TLRESTORELF();
}

void Language_Execute_DispatchHandler (quitCode)
TLint4	quitCode;
{
    TLBINDREG((*pd), struct Language_Execute_ProcessDescriptor);
    register struct Language_Execute_HandlerArea	*ha;
    TLSTKCHKSLF(101129);
    TLSETF();
    TLSETL(101129);
    pd = &((*(Language_Execute_RQHead)));
    TLSETL(101131);
    ha = (*pd).activeHandler;
    TLINCL();
    (*pd).runningHandler = ha;
    TLSETL(101134);
    if (ha != ((struct Language_Execute_HandlerArea *) 0)) {
	TLSETL(101138);
	TLSTRCTASS(ha->srcPos, (*pd).srcPos, struct SrcPosition);
	TLINCL();
	ha->quitCode = quitCode;
	TLSETL(101142);
	(*pd).activeHandler = ha->nextHandler;
	TLSETL(101145);
	Language_Execute_globalPC = (TLaddressint) (ha->handlerRoutine);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (ha->savedRegisters.sp);
	TLINCL();
	(*pd).fp = (TLaddressint) (ha->savedRegisters.fp);
    } else {
	TLstring	message;
	TLSETL(101152);
	TLSTRASS(255, message, "");
	TLSETL(101154);
	if ((unsigned long) ((*pd).name) != 0) {
	    TLSETL(101155);
	    {
		TLstring	__x1890;
		TL_TLS_TLSCAT("Process \"", (* (TLstring *) ((*pd).name)), __x1890);
		{
		    TLstring	__x1889;
		    TL_TLS_TLSCAT(__x1890, "\": ", __x1889);
		    TLSTRASS(255, message, __x1889);
		};
	    };
	};
	TLSETL(101157);
	if ((((*pd).abort.quitCode) != 0) && (quitCode == ((*pd).abort.quitCode))) {
	    TLSETL(101159);
	    TLSTRCATASS(message, (*pd).abort.errorMsg, 255);
	} else {
	    TLSETL(101162);
	    {
		TLstring	__x1893;
		TL_TLS_TLSVIS((TLint4) quitCode, (TLint4) 1, (TLint4) 10, __x1893);
		{
		    TLstring	__x1892;
		    TL_TLS_TLSCAT("Quit #", __x1893, __x1892);
		    TLSTRCATASS(message, __x1892, 255);
		};
	    };
	};
	TLSETL(101167);
	Language_ErrorModule_Message(&((*pd).srcPos), (Language_ErrorModule_Severity) 3, message);
    };
    TLRESTORELF();
}

extern void TLEABT ();

void Language_Execute_ExtraRoutines (op)
Language_Opcode	op;
{
    TLSTKCHKSLF(101184);
    TLSETF();
    TLSETL(101184);
    switch (op) {
	case 77:
	    {
		TLint4	stream;
		struct MIO_EventDescriptor	event;
		TLSETL(101188);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101195);
		    {
			TLstring	__x1897;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1897);
			{
			    TLstring	__x1896;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x1897, __x1896);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1896);
			};
		    };
		};
		TLSETL(101197);
		event.mode = 2;
		TLINCL();
		event.count = 1;
		TLINCL();
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLSETL(101200);
		    Language_Execute_globalSP -= 0;
		    TLINCL();
		    if (TL_TLI_TLIEOF((TLint4) stream)) {
			TLSETL(101202);
			(* (TLnat4 *) Language_Execute_globalSP) = 1;
		    } else {
			TLSETL(101204);
			(* (TLnat4 *) Language_Execute_globalSP) = 0;
		    };
		} else {
		    TLSETL(101207);
		    Language_Execute_globalPC -= Language_codeOprSize;
		    TLSETL(101209);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 120:
	    {
		TLSETL(101214);
		Language_Execute_Get();
	    }
	    break;
	case 181:
	    {
		TLSETL(101217);
		Language_Execute_Open();
	    }
	    break;
	case 196:
	    {
		TLSETL(101220);
		Language_Execute_Put();
	    }
	    break;
	case 198:
	    {
		TLaddressint	startPC;
		TLaddressint	startSP;
		register TLaddressint	statusAddr;
		TLint4	stream;
		register TLaddressint	resultAddr;
		struct MIO_EventDescriptor	event;
		TLSETL(101225);
		startPC = (TLaddressint) ((unsigned long) Language_Execute_globalPC - Language_codeOprSize);
		TLINCL();
		startSP = (TLaddressint) Language_Execute_globalSP;
		TLSETL(101228);
		statusAddr = (TLaddressint) ((* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))));
		TLSETL(101230);
		Language_Execute_globalSP += 4;
		TLSETL(101232);
		TL_TLI_TLIXSN = (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP)));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLINCL();
		stream = Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)];
		TLINCL();
		if (stream == -3) {
		    TLSETL(101240);
		    {
			TLstring	__x1905;
			TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1905);
			{
			    TLstring	__x1904;
			    TL_TLS_TLSCAT("I/O attempted on closed stream ", __x1905, __x1904);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1904);
			};
		    };
		};
		TLSETL(101242);
		resultAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		Language_Execute_globalSP += 4;
		TLSETL(101251);
		event.mode = 1;
		TLINCL();
		event.count = 0;
		TLSETL(101254);
		if (Language_Execute_HasEvent((TLint4) TL_TLI_TLIXSN, &(event))) {
		    TLint4	status;
		    TLint4	sizeRead;
		    TLSETL(101258);
		    TL_TLI_TLISSS (&status, (TLint4) stream, (TLint2) 3);
		    TL_TLI_TLIRER (&sizeRead, &((* (TLint4 *) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + 4))))), (TLint4) ((* (TLint4 *) Language_Execute_globalSP)), &status, (TLint2) stream);
		    TLSETL(101261);
		    if ((unsigned long) statusAddr != 0) {
			TLSETL(101262);
			(* (TLint4 *) statusAddr) = status;
		    };
		    TLSETL(101264);
		    if ((unsigned long) resultAddr != 0) {
			TLSETL(101265);
			(* (TLint4 *) resultAddr) = sizeRead;
		    };
		    TLSETL(101267);
		    Language_Execute_globalSP += 8;
		} else {
		    TLSETL(101269);
		    Language_Execute_globalPC = (TLaddressint) startPC;
		    TLINCL();
		    Language_Execute_globalSP = (TLaddressint) startSP;
		    TLSETL(101272);
		    Language_Execute_EventQueueInsert((TLint4) TL_TLI_TLIXSN, &(event));
		};
	    }
	    break;
	case 216:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101278);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101281);
		if ((Language_Execute_RQHead->activeStream) == 0) {
		    TLSETL(101282);
		    if (streamMode == 1) {
			TLSETL(101283);
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -2;
		    } else {
			TLSETL(101285);
			TLASSERT (streamMode == 2);
			TLINCL();
			(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = -1;
		    };
		} else {
		    TLSETL(101289);
		    (* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = Language_Execute_RQHead->activeStream;
		};
		TLSETL(101291);
		Language_Execute_globalSP += 4;
	    }
	    break;
	case 217:
	    {
		Language_SetStreamKind	streamMode;
		TLSETL(101297);
		streamMode = (* (Language_SetStreamKind *) Language_Execute_globalPC);
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
		TLSETL(101300);
		(* (TLaddressint *) ((* (TLaddressint *) Language_Execute_globalSP))) = (TLaddressint) ((* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))));
		TLSETL(101302);
		Language_Execute_globalSP += 4;
		TLINCL();
		TL_TLI_TLIXSN = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + (2 * 4)));
		TLINCL();
		(* (TLint4 *) ((* (TLaddressint *) Language_Execute_globalSP))) = TL_TLI_TLIXSN;
		TLINCL();
		Language_Execute_globalSP += 12;
		TLSETL(101307);
		if (TL_TLI_TLIXSN < (- 2)) {
		    TLSETL(101309);
		    Language_Execute_BadStreamAbortMessage((TLint4) TL_TLI_TLIXSN, "I/O");
		} else {
		    TLSETL(101309);
		    if (TL_TLI_TLIXSN > 20) {
			TLSETL(101313);
			{
			    TLstring	__x1927;
			    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1927);
			    {
				TLstring	__x1926;
				TL_TLS_TLSCAT("I/O attempted on illegal stream number ", __x1927, __x1926);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1926);
			    };
			};
		    };
		};
		TLSETL(101314);
		if ((Language_Execute_fileMap[TLINRANGELOW(TL_TLI_TLIXSN, -2, 20, 1)]) == -3) {
		    Language_StreamModeSet	openMode;
		    TLSETL(101315);
		    if (TL_TLI_TLIXSN > Language_Execute_numArguments) {
			TLSETL(101319);
			{
			    TLstring	__x1929;
			    TL_TLS_TLSVIS((TLint4) TL_TLI_TLIXSN, (TLint4) 1, (TLint4) 10, __x1929);
			    {
				TLstring	__x1928;
				TL_TLS_TLSCAT("I/O attempted on unopened or closed stream ", __x1929, __x1928);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1928);
			    };
			};
		    };
		    TLSETL(101321);
		    openMode = (TLSMLSMLSETCONST(TLINRANGELOW(streamMode, 0, 5, 19)));
		    TLINCL();
		    if (streamMode == 0) {
			TLSETL(101323);
			openMode |= 0x2;
		    };
		    TLSETL(101326);
		    Language_Execute_OpenArgumentFile((Language_StreamModeSet) openMode, (TLboolean) 1);
		};
	    }
	    break;
	case 55:
	    {
		register TLint4	Index;
		TLSETL(101333);
		if (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 0) {
		    TLSETL(101334);
		    Index = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		} else {
		    TLSETL(101336);
		    TLASSERT (((* (Language_SubstringKind *) Language_Execute_globalPC)) == 1);
		    TLINCL();
		    Index = ((* (TLint4 *) Language_Execute_globalSP)) - ((* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4)));
		};
		TLSETL(101340);
		if (Index <= 0) {
		    TLSETL(101343);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is less than 1");
		} else {
		    TLSETL(101343);
		    if (Index > ((* (TLint4 *) Language_Execute_globalSP))) {
			TLSETL(101346);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring index is greater than length of char(n)");
		    };
		};
		TLSETL(101348);
		(* (TLaddressint *) ((unsigned long) Language_Execute_globalSP + (2 * 4))) += Index - 1;
		TLINCL();
		Language_Execute_globalSP += 8;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	case 56:
	    {
		register TLint4	startIndex;
		register TLint4	endIndex;
		register TLint4	slen;
		register TLaddressint	tAddr;
		register TLaddressint	sAddr;
		TLSETL(101356);
		slen = (* (TLint4 *) ((unsigned long) Language_Execute_globalSP + 4));
		TLSETL(101358);
		switch ((* (Language_SubstringKind *) Language_Execute_globalPC)) {
		    case 2:
			{
			    TLSETL(101360);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 3:
			{
			    TLSETL(101364);
			    startIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4)));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    case 4:
			{
			    TLSETL(101368);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = (* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4));
			}
			break;
		    case 5:
			{
			    TLSETL(101372);
			    startIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + (2 * 4))));
			    TLINCL();
			    endIndex = slen - ((* (TLint4 *) (((unsigned long) Language_Execute_globalSP + 4) + 4)));
			}
			break;
		    default:
			TLCASEABORT;
		};
		TLSETL(101376);
		if (startIndex <= 0) {
		    TLSETL(101379);
		    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring is less than 1");
		} else {
		    TLSETL(101379);
		    if ((startIndex - endIndex) > 1) {
			TLSETL(101382);
			Language_Execute_ExecutionError_Abort((TLint4) 10000, "Left bound of char substring exceeds right bound by more than 1");
		    } else {
			TLSETL(101382);
			if (endIndex > slen) {
			    TLSETL(101385);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, "Right bound of char substring is greater than size of char(n)");
			} else {
			    TLSETL(101385);
			    if ((endIndex - startIndex) >= 256) {
				TLSETL(101388);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "Char substring too large to fit into \'string\'");
			    };
			};
		    };
		};
		TLSETL(101391);
		(* (TLint1 *) ((* (TLaddressint *) Language_Execute_globalSP))) = 0;
		TLSETL(101394);
		tAddr = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLINCL();
		sAddr = (TLaddressint) (((unsigned long) ((* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4)))) + startIndex) - 1);
		TLSETL(101398);
		{
		    register TLint4	__x1446;
		    TLint4	__x1951;
		    __x1951 = endIndex;
		    __x1446 = startIndex;
		    if (__x1446 <= __x1951) {
			for(;;) {
			    register TLnat4	val;
			    TLSETL(101399);
			    val = (* (TLnat1 *) sAddr);
			    TLINCL();
			    sAddr += 1;
			    TLSETL(101402);
			    if ((val & 127) == 0) {
				TLSETL(101405);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, "char(n) converted to string contains EOS or uninitchar");
			    };
			    TLSETL(101406);
			    (* (TLnat1 *) tAddr) = val;
			    TLINCL();
			    tAddr += 1;
			    if (__x1446 == __x1951) break;
			    __x1446++;
			}
		    };
		};
		TLSETL(101409);
		(* (TLnat1 *) tAddr) = 0;
		TLSETL(101411);
		(* (TLaddressint *) (((unsigned long) Language_Execute_globalSP + 4) + (3 * 4))) = (TLaddressint) ((* (TLaddressint *) Language_Execute_globalSP));
		TLSETL(101413);
		Language_Execute_globalSP += 16;
		TLINCL();
		Language_Execute_globalPC += Language_codeInt1Size;
	    }
	    break;
	default :
	    {
		TLSETL(101417);
		if (op > 254) {
		    TLSETL(101420);
		    {
			TLstring	__x1958;
			TL_TLS_TLSVIS((TLint4) (* (TLnat2 *) &op), (TLint4) 1, (TLint4) 10, __x1958);
			{
			    TLstring	__x1957;
			    TL_TLS_TLSCAT("Undecodeable opcode #", __x1958, __x1957);
			    Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1957);
			};
		    };
		} else {
		    TLSETL(101428);
		    {
			TLstring	__x1961;
			TL_TLS_TLSVIS((TLint4) (* (TLnat2 *) &op), (TLint4) 1, (TLint4) 10, __x1961);
			{
			    TLstring	__x1960;
			    TL_TLS_TLSCAT("Unimplemented opcode ", "#", __x1960);
			    {
				TLstring	__x1959;
				TL_TLS_TLSCAT(__x1960, __x1961, __x1959);
				Language_Execute_ExecutionError_Abort((TLint4) 10000, __x1959);
			    };
			};
		    };
		};
	    }
	    break;
    };
    TLRESTORELF();
}

void Language_Execute_EndExecution () {
    TLSTKCHKSLF(101434);
    TLSETF();
    TLSETL(101434);
    Language_Execute_failedOpenStream = -10;
    TLSETL(101436);
    Language_Execute_CloseArguments();
    TLINCL();
    Language_Execute_CloseAllFiles();
    TLRESTORELF();
}

void Language_Execute_RecoverAllMemory () {
    TLSTKCHKSLF(101442);
    TLSETF();
    TLSETL(101442);
    Language_Execute_EndExecution();
    TLINCL();
    Language_Execute_Heap_CleanUp();
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLRESTORELF();
}
TLint4	Language_Execute_quantaCount;

void Language_Execute_Initialize (startPC, maxStackSize, inName, outName, args, numArgs)
TLaddressint	startPC;
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x1648	args;
TLint4	numArgs;
{
    TLnat4	stackSize;
    TLaddressint	stackBase;

    extern void TL_TLA_TLARZ ();
    TLSTKCHKSLF(101458);
    TLSETF();
    TLSETL(101458);
    if (strcmp(inName, "") == 0) {
	TLSETL(101459);
	Language_Execute_fileMap[0] = -2;
    } else {
	TLint4	inStream;
	TLSETL(101462);
	TL_TLI_TLIOF ((TLnat2) 2, inName, &inStream);
	TLINCL();
	if (inStream == 0) {
	    TLSETL(101467);
	    {
		TLstring	__x1963;
		TL_TLS_TLSCAT("Unable to open file \'", inName, __x1963);
		{
		    TLstring	__x1962;
		    TL_TLS_TLSCAT(__x1963, "\' for input", __x1962);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1962);
		};
	    };
	};
	TLSETL(101468);
	Language_Execute_fileMap[0] = inStream;
    };
    TLSETL(101471);
    if (strcmp(outName, "") == 0) {
	TLSETL(101472);
	Language_Execute_fileMap[1] = -1;
	TLINCL();
	Language_Execute_fileMap[2] = -1;
    } else {
	TLint4	outStream;
	TLSETL(101476);
	TL_TLI_TLIOF ((TLnat2) 4, outName, &outStream);
	TLINCL();
	if (outStream == 0) {
	    TLSETL(101481);
	    {
		TLstring	__x1965;
		TL_TLS_TLSCAT("Unable to open file \'", outName, __x1965);
		{
		    TLstring	__x1964;
		    TL_TLS_TLSCAT(__x1965, "\' for output", __x1964);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1964);
		};
	    };
	};
	TLSETL(101482);
	Language_Execute_fileMap[1] = outStream;
	TLINCL();
	Language_Execute_fileMap[2] = outStream;
    };
    TLSETL(101486);
    Language_Execute_numArguments =  TLSIMPLEMIN(numArgs, 20);
    TLSETL(101488);
    {
	register TLint4	i;
	TLint4	__x1966;
	__x1966 = Language_Execute_numArguments;
	i = 0;
	if (i <= __x1966) {
	    for(;;) {
		TLSETL(101489);
		TL_TLB_TLBNWU(& Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)], (TLint4)  sizeof (		Language_StringDef));
		TLINCL();
		if ((Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)]) == ((Language_StringDef *) 0)) {
		    TLSETL(101494);
		    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for arguments");
		};
		TLSETL(101495);
		TLSTRASS(255, (*(Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)])), args[TLINRANGELOW(i, 0, 20, 1)]);
		if (i == __x1966) break;
		i++;
	    }
	};
    };
    TLSETL(101499);
    stackSize = maxStackSize * 1024;
    TLINCL();
    if (stackSize < 0x1000) {
	TLSETL(101501);
	stackSize = 4096;
    };
    TLSETL(101505);
    for(;;) {
	TLSETL(101507);
	Language_Execute_Heap_Alloc(&(stackBase), (TLnat4) ((256 + stackSize) + sizeof(struct Language_Execute_ProcessDescriptor)));
	if ((unsigned long) stackBase != 0) {
	    break;
	};
	TLSETL(101508);
	if (stackSize > (64 * 1024)) {
	    TLSETL(101509);
	    stackSize /= 2;
	} else {
	    TLSETL(101511);
	    stackSize -= 2048;
	};
	TLSETL(101513);
	if (stackSize < 0x1000) {
	    TLSETL(101517);
	    Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, "Unable to allocate memory for stack");
	};
    };
    TLSETL(101519);
    Language_Execute_stackAllocated = stackSize;
    TLSETL(101521);
    * (TLnat4 *) &Language_Execute_RQHead = ((unsigned long) stackBase + 256) + stackSize;
    TLINCL();
    Language_Execute_RQHead->pc = (TLaddressint) startPC;
    TLINCL();
    Language_Execute_RQHead->fp = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->sp = (TLaddressint) ((* (TLnat4 *) &Language_Execute_RQHead) - 4);
    TLINCL();
    (* (TLaddressint *) (Language_Execute_RQHead->sp)) = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->minimumSP = (TLaddressint) ((unsigned long) stackBase + 256);
    TLINCL();
    Language_Execute_RQHead->stackBase = (TLaddressint) stackBase;
    TLINCL();
    TLSTRCTASS(Language_Execute_RQHead->srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    Language_Execute_RQHead->activeStream = 0;
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->errMessage, "");
    TLINCL();
    TLSTRASS(255, Language_Execute_RQHead->prevErrMessage, "");
    TLINCL();
    Language_Execute_RQHead->name = (TLaddressint) 0;
    TLINCL();
    Language_Execute_RQHead->nextProcess = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_RQHead->dispatchPriority = 1000;
    TLINCL();
    Language_Execute_RQHead->totalPause = 0;
    TLINCL();
    Language_Execute_RQHead->activeHandler = (struct Language_Execute_HandlerArea *) 0;
    TLINCL();
    Language_Execute_RQHead->runningHandler = (struct Language_Execute_HandlerArea *) 0;
    TLSETL(101548);
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLSETL(101551);
    Language_Execute_ExecutionError_Initialize();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_quantaCount = 20;
    TLINCL();
    Language_Execute_processCount = 0;
    TLSETL(101559);
    Language_Execute_Kernel_Initialize();
    TLSETL(101563);
    TL_TLA_TLARZ();
    TLINCL();
    MIO_Init();
    TLRESTORELF();
}

extern void Math_Arctan ();

extern void Math_Arctand ();

extern void Math_Ceil ();

extern void Math_Cos ();

extern void Math_Cosd ();

extern void Math_Exp ();

extern void Math_Floor ();

extern void Math_Intreal ();

extern void Math_Ln ();

extern void Math_Natreal ();

extern void Math_Rand ();

extern void Math_Randint ();

extern void Math_Randnext ();

extern void Math_Randomize ();

extern void Math_Randseed ();

extern void Math_Round ();

extern void Math_Sign ();

extern void Math_Sin ();

extern void Math_Sind ();

extern void Math_Sqrt ();

extern void String_Erealstr ();

extern void String_Frealstr ();

extern void String_Index ();

extern void String_Length ();

extern void String_Realstr ();

extern void String_Repeat ();

extern void String_Strreal ();

extern void Language_Execute_System_Clock ();

extern void Language_Execute_System_Date ();

extern void Language_Execute_System_Fetcharg ();

extern void Language_Execute_System_Flushstreams ();

extern void Language_Execute_System_Getenv ();

extern void Language_Execute_System_Getpid ();

extern void Language_Execute_System_Nargs ();

extern void Language_Execute_System_Setactive ();

extern void Language_Execute_System_Simutime ();

extern void Language_Execute_System_Sysclock ();

extern void Language_Execute_System_System ();

extern void Language_Execute_System_Time ();

extern void Language_Execute_System_Wallclock ();

extern void Limits_Getexp ();

extern void Limits_Rreb ();

extern void Limits_Setexp ();

extern void Language_Execute_Graphics_Drawpic ();

extern void Language_Execute_Graphics_Getch ();

extern void Language_Execute_Graphics_Hasch ();

extern void Language_Execute_Graphics_Sizepic ();

extern void Language_Execute_Graphics_Takepic ();

extern void Language_Execute_Event_Getevent ();

extern void Language_Execute_Event_Hasevent ();

extern void MT_InterpretIfc ();

extern void Star_initialize ();

extern void Star_getToken ();

extern void Star_finalize ();
struct	Language_Execute_RunDescriptor {
    Language_ReturnState	state;
    TLboolean	doQuit;
};

extern void Language_Execute_Run ();
extern TLint4	TL_TLI_TLIARC;

extern void TL_TLI_TLIFA ();

extern void TL_TLX_TLXGE ();

extern void TL_TLX_TLXDT ();

extern void TL_TLX_TLXTM ();

extern void TL_TLX_TLXCL ();

extern void TL_TLX_TLXSC ();

extern void time ();

extern void TL_TLX_TLXSYS ();

extern TLint4 getpid ();

extern void TL_TLI_TLIFS ();

extern void TL_TLK_TLKUEXIT ();
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKUDMPA ();

extern void TL_TLK_TLKCINI ();
extern TLboolean	TL_TLK_TLKCLKON;
extern TLnat4	TL_TLK_TLKHZ;
extern TLnat4	TL_TLK_TLKCRESO;
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKPSID ();

extern TLnat4 TL_TLK_TLKPGID ();

extern void TL_TLK_TLKRSETP ();

void Language_Execute_Executor (runStatus)
struct Language_RunStatus	*runStatus;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(101637);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(101637);
	(*runStatus).state = 0;
	TLSETL(101639);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101640);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101644);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101646);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TLSETL(101648);
	TL_TLI_TLIFS();
	if (quitCode.quitCode != 1) {
	    TLSETL(101649);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	struct Language_Execute_RunDescriptor	runDesc;
	TLSETF();
	TLSETL(101658);
	Language_Execute_EventQueueDispatch();
	TLINCL();
	Language_Execute_Kernel_RunQueueDispatch();
	if (Language_Execute_RQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101660);
	    if (Language_Execute_EQHead == ((struct Language_Execute_ProcessDescriptor *) 0)) {
		TLSETL(101661);
		(*runStatus).state = 0;
	    } else {
		TLSETL(101663);
		if (Language_Execute_allWaitingForKeyboard) {
		    TLSETL(101664);
		    (*runStatus).state = 6;
		} else {
		    TLSETL(101665);
		    if (Language_Execute_allWaitingForMouse) {
			TLSETL(101666);
			(*runStatus).state = 7;
		    } else {
			TLSETL(101667);
			if (Language_Execute_allWaitingForDelay) {
			    TLSETL(101668);
			    (*runStatus).state = 8;
			    TLINCL();
			    (*runStatus).moreStateInfo = Language_Execute_minimumDelayCount;
			} else {
			    TLSETL(101671);
			    (*runStatus).state = 2;
			};
		    };
		};
	    };
	    TLSETL(101674);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    (*runStatus).threadId = (TLaddressint) 0;
	    TLSETL(101689);
	    TL_TLE_TLEHX();
	    TLRESTORELF();
	    return;
	};
	TLSETL(101690);
	Language_Execute_globalPC = (TLaddressint) (Language_Execute_RQHead->pc);
	TLINCL();
	Language_Execute_globalSP = (TLaddressint) (Language_Execute_RQHead->sp);
	TLSETL(101700);
	Language_Execute_SetActive(&(Language_Execute_RQHead->activeStream));
	TLSETL(101702);
	for(;;) {
	    TLSETL(101703);
	    Language_Execute_Run(&(runDesc));
	    if (!(runDesc.doQuit)) {
		break;
	    };
	    TLSETL(101706);
	    Language_Execute_ExecutionError_GetAbort(&(Language_Execute_RQHead->abort.quitCode), Language_Execute_RQHead->abort.errorMsg);
	    TLINCL();
	    Language_Execute_DispatchHandler((TLint4) (Language_Execute_RQHead->abort.quitCode));
	};
	TLSETL(101708);
	(*runStatus).state = runDesc.state;
	TLSETL(101710);
	if (Language_Execute_RQHead != ((struct Language_Execute_ProcessDescriptor *) 0)) {
	    TLSETL(101711);
	    Language_Execute_RQHead->pc = (TLaddressint) Language_Execute_globalPC;
	    TLINCL();
	    Language_Execute_RQHead->sp = (TLaddressint) Language_Execute_globalSP;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_Execute_RQHead->srcPos, struct SrcPosition);
	} else {
	    TLSETL(101715);
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	};
	TLSETL(101717);
	(*runStatus).threadId = (TLaddressint) (* (TLnat4 *) &Language_Execute_RQHead);
	TL_TLE_TLEHX();
    }
}

void Language_Execute () {
    TLSAVELF();
    TLSETF();
    TLSETL(100129);
    Language_Execute_externalExecutionTimeoutFlag = 0;
    TLSETL(100131);
    Language_Execute_stackAllocated = 0;
    ExecutionError();
    Language_Execute_Heap();
    MIO();
    TLSETL(100181);
    Language_Execute_numArguments = 0;
    TLSETL(100186);
    Language_Execute_numFilesOpen = 0;
    TLSETL(100191);
    Language_Execute_fileMap[0] = -2;
    TLINCL();
    Language_Execute_fileMap[1] = -1;
    TLINCL();
    Language_Execute_fileMap[2] = -1;
    TLINCL();
    {
	register TLint4	i;
	for (i = 1; i <= 20; i++) {
	    TLSETL(100195);
	    Language_Execute_fileMap[TLINRANGELOW(i, -2, 20, 1)] = -3;
	    TLINCL();
	    Language_Execute_argumentNames[TLINRANGELOW(i, 0, 20, 1)] = (Language_StringDef *) 0;
	};
    };
    TLSETL(100214);
    TL_TLI_TLIUXS = 1;
    TLSETL(100231);
    Language_Execute_RQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_EQHead = (struct Language_Execute_ProcessDescriptor *) 0;
    TLINCL();
    Language_Execute_Chrono = 0;
    TLINCL();
    Language_Execute_processCount = 0;
    TLSETL(100309);
    Language_Execute_failedOpenStream = -10;
    Language_Execute_Kernel();
    Math();
    String();
    Language_Execute_System();
    Limits();
    Language_Execute_Graphics();
    Language_Execute_Event();
    MT();
    Star();
    TLRESTORELF();
}
